// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: io/flights/flight_designator.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace PassKit.Grpc.Flights {

  /// <summary>Holder for reflection information generated from io/flights/flight_designator.proto</summary>
  public static partial class FlightDesignatorReflection {

    #region Descriptor
    /// <summary>File descriptor for io/flights/flight_designator.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static FlightDesignatorReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiJpby9mbGlnaHRzL2ZsaWdodF9kZXNpZ25hdG9yLnByb3RvEgdmbGlnaHRz",
            "Gh5pby9jb21tb24vY29tbW9uX29iamVjdHMucHJvdG8aGWlvL2NvbW1vbi9w",
            "cm94aW1pdHkucHJvdG8aFWlvL2NvbW1vbi9saW5rcy5wcm90bxoucHJvdG9j",
            "LWdlbi1vcGVuYXBpdjIvb3B0aW9ucy9hbm5vdGF0aW9ucy5wcm90byKECQoQ",
            "RmxpZ2h0RGVzaWduYXRvchIqCgtjYXJyaWVyQ29kZRgBIAEoCUIVkkESigEP",
            "XltBLVowLTldezMsNH0kEhsKDGZsaWdodE51bWJlchgCIAEoCUIFkkECeAUS",
            "GwoJdmFsaWRGcm9tGAMgASgLMgguaW8uRGF0ZRIQCghyZXZpc2lvbhgEIAEo",
            "DRIZCgZhY3RpdmUYBSABKAhCCZJBBjoEVFJVRRIpCghzY2hlZHVsZRgGIAEo",
            "CzIXLmZsaWdodHMuRmxpZ2h0U2NoZWR1bGUSJgoUb3BlcmF0aW5nQ2Fycmll",
            "ckNvZGUYByABKAlCCJJBBXgDgAECEiQKFW9wZXJhdGluZ0ZsaWdodE51bWJl",
            "chgIIAEoCUIFkkECeAUSHgoWY29kZVNoYXJlRmxpZ2h0TnVtYmVycxgJIAMo",
            "CRIOCgZvcmlnaW4YCiABKAkSEwoLZGVzdGluYXRpb24YCyABKAkSFQoNdHJh",
            "bnNpdFBvaW50cxgMIAMoCRIZChFkZXBhcnR1cmVUZXJtaW5hbBgNIAEoCRIX",
            "Cg9hcnJpdmFsVGVybWluYWwYDiABKAkSGAoQdHJhbnNpdFRlcm1pbmFscxgP",
            "IAMoCRIvCg5ib2FyZGluZ1BvbGljeRgQIAEoDjIXLmZsaWdodHMuQm9hcmRp",
            "bmdQb2xpY3kSMQoPc2VhdENsYXNzUG9saWN5GBEgASgOMhguZmxpZ2h0cy5T",
            "ZWF0Q2xhc3NQb2xpY3kSJQoGYWxlcnRzGBIgAygOMhUuZmxpZ2h0cy5GbGln",
            "aHRBbGVydHMSFgoOcGFzc1RlbXBsYXRlSWQYEyABKAkSJgoTYXV0b0ludmFs",
            "aWRhdGVBZnRlchgUIAEoDUIJkkEGOgQyODgwEikKHWF1dG9JbnZhbGlkYXRl",
            "Q2FuY2VsbGVkUGFzc2VzGBUgASgIQgIYARIxChBsb2NhdGlvbk1lc3NhZ2Vz",
            "GBYgAygLMg8uaW8uR1BTTG9jYXRpb25CBpJBA6ABChIqCg5iZWFjb25NZXNz",
            "YWdlcxgXIAMoCzIKLmlvLkJlYWNvbkIGkkEDoAEKEh4KDGRlZmF1bHRMaW5r",
            "cxgYIAMoCzIILmlvLkxpbmsSGAoQQ29uZGl0aW9uYWxJdGVtcxgZIAEoCBId",
            "ChVCYXJjb2RlQWRkaXRpb25hbERhdGEYGiABKAkSOAoZaW52YWxpZGF0ZUNh",
            "bmNlbGxlZFBhc3NlcxgbIAEoDjIKLmlvLlRvZ2dsZUIJkkEGOgRUUlVFOtEB",
            "kkHNAQrKASoRRmxpZ2h0IERlc2lnbmF0b3IyWkEgZmxpZ2h0IGRlc2lnbmF0",
            "b3IgcmVjb3JkIGRlc2NyaWJlcyBtb3N0bHkgc3RhdGljIGRhdGEgd2l0aCBy",
            "ZWdhcmQgdG8gYSBmbGlnaHQgb3BlcmF0aW9uLtIBC2NhcnJpZXJDb2Rl0gEM",
            "ZmxpZ2h0TnVtYmVy0gEGb3JpZ2lu0gEIc2NoZWR1bGXSAQhyZXZpc2lvbtIB",
            "C2Rlc3RpbmF0aW9u0gEOcGFzc1RlbXBsYXRlSWQi5gEKF0ZsaWdodERlc2ln",
            "bmF0b3JSZXF1ZXN0Eh0KC2NhcnJpZXJDb2RlGAEgASgJQgiSQQV4A4ABAhIb",
            "CgxmbGlnaHROdW1iZXIYAiABKAlCBZJBAngFEhAKCHJldmlzaW9uGAMgASgN",
            "On2SQXoKeCoZRmxpZ2h0IERlc2lnbmF0b3IgUmVxdWVzdDI+VXNlZCBmb3Ig",
            "cmV0cmlldmluZyBkZXRhaWxzIG9mIGEgcGFydGljdWxhciBmbGlnaHQgZGVz",
            "aWduYXRvci7SAQtjYXJyaWVyQ29kZdIBDGZsaWdodE51bWJlciKiAgoORmxp",
            "Z2h0U2NoZWR1bGUSJAoGbW9uZGF5GAEgASgLMhQuZmxpZ2h0cy5GbGlnaHRU",
            "aW1lcxIlCgd0dWVzZGF5GAIgASgLMhQuZmxpZ2h0cy5GbGlnaHRUaW1lcxIn",
            "Cgl3ZWRuZXNkYXkYAyABKAsyFC5mbGlnaHRzLkZsaWdodFRpbWVzEiYKCHRo",
            "dXJzZGF5GAQgASgLMhQuZmxpZ2h0cy5GbGlnaHRUaW1lcxIkCgZmcmlkYXkY",
            "BSABKAsyFC5mbGlnaHRzLkZsaWdodFRpbWVzEiYKCHNhdHVyZGF5GAYgASgL",
            "MhQuZmxpZ2h0cy5GbGlnaHRUaW1lcxIkCgZzdW5kYXkYByABKAsyFC5mbGln",
            "aHRzLkZsaWdodFRpbWVzIqIBCgtGbGlnaHRUaW1lcxIoChZzY2hlZHVsZWRE",
            "ZXBhcnR1cmVUaW1lGAEgASgLMgguaW8uVGltZRIeCgxib2FyZGluZ1RpbWUY",
            "AiABKAsyCC5pby5UaW1lEiEKD2dhdGVDbG9zaW5nVGltZRgDIAEoCzIILmlv",
            "LlRpbWUSJgoUc2NoZWR1bGVkQXJyaXZhbFRpbWUYBCABKAsyCC5pby5UaW1l",
            "KqkBCgxGbGlnaHRBbGVydHMSDQoJTk9fQUxFUlRTEAASDgoKQUxMX0FMRVJU",
            "UxABEhgKFERFUEFSVFVSRV9HQVRFX0FMRVJUEAISGAoUREVQQVJUVVJFX1RJ",
            "TUVfQUxFUlQQBBIWChJBUlJJVkFMX0dBVEVfQUxFUlQQCBIWChJBUlJJVkFM",
            "X1RJTUVfQUxFUlQQEBIWChJCQUdHQUdFX0JFTFRfQUxFUlQQICptCg5Cb2Fy",
            "ZGluZ1BvbGljeRIfChtCT0FSRElOR19QT0xJQ1lfVU5TUEVDSUZJRUQQABIO",
            "CgpaT05FX0JBU0VEEAESDwoLR1JPVVBfQkFTRUQQAhIZChVCT0FSRElOR19Q",
            "T0xJQ1lfT1RIRVIQAyqDAQoPU2VhdENsYXNzUG9saWN5EiEKHVNFQVRfQ0xB",
            "U1NfUE9MSUNZX1VOU1BFQ0lGSUVEEAASDwoLQ0FCSU5fQkFTRUQQARIPCgtD",
            "TEFTU19CQVNFRBACEg4KClRJRVJfQkFTRUQQAxIbChdTRUFUX0NMQVNTX1BP",
            "TElDWV9PVEhFUhAEKh8KCUF1dGhvcml0eRIICgRJQVRBEAASCAoESUNBTxAB",
            "Ql8KGGNvbS5wYXNza2l0LmdycGMuRmxpZ2h0c1osc3Rhc2gucGFzc2tpdC5j",
            "b20vaW8vbW9kZWwvc2RrL2dvL2lvL2ZsaWdodHOqAhRQYXNzS2l0LkdycGMu",
            "RmxpZ2h0c2IGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::PassKit.Grpc.CommonObjectsReflection.Descriptor, global::PassKit.Grpc.ProximityReflection.Descriptor, global::PassKit.Grpc.LinksReflection.Descriptor, global::PassKit.Grpc.Gateway.ProtocGenOpenapiv2.Options.AnnotationsReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::PassKit.Grpc.Flights.FlightAlerts), typeof(global::PassKit.Grpc.Flights.BoardingPolicy), typeof(global::PassKit.Grpc.Flights.SeatClassPolicy), typeof(global::PassKit.Grpc.Flights.Authority), }, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::PassKit.Grpc.Flights.FlightDesignator), global::PassKit.Grpc.Flights.FlightDesignator.Parser, new[]{ "CarrierCode", "FlightNumber", "ValidFrom", "Revision", "Active", "Schedule", "OperatingCarrierCode", "OperatingFlightNumber", "CodeShareFlightNumbers", "Origin", "Destination", "TransitPoints", "DepartureTerminal", "ArrivalTerminal", "TransitTerminals", "BoardingPolicy", "SeatClassPolicy", "Alerts", "PassTemplateId", "AutoInvalidateAfter", "AutoInvalidateCancelledPasses", "LocationMessages", "BeaconMessages", "DefaultLinks", "ConditionalItems", "BarcodeAdditionalData", "InvalidateCancelledPasses" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::PassKit.Grpc.Flights.FlightDesignatorRequest), global::PassKit.Grpc.Flights.FlightDesignatorRequest.Parser, new[]{ "CarrierCode", "FlightNumber", "Revision" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::PassKit.Grpc.Flights.FlightSchedule), global::PassKit.Grpc.Flights.FlightSchedule.Parser, new[]{ "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::PassKit.Grpc.Flights.FlightTimes), global::PassKit.Grpc.Flights.FlightTimes.Parser, new[]{ "ScheduledDepartureTime", "BoardingTime", "GateClosingTime", "ScheduledArrivalTime" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// Flight alerts automatically update boarding passes as information becomes available or changes. Note that these services may incur additional usage charges.
  /// </summary>
  public enum FlightAlerts {
    /// <summary>
    /// Boarding passes will not automatically update.
    /// </summary>
    [pbr::OriginalName("NO_ALERTS")] NoAlerts = 0,
    /// <summary>
    /// Boarding passes will automatically update whenever a change to the departure gate/time, arrival gate/time or baggage belt information is detected.
    /// </summary>
    [pbr::OriginalName("ALL_ALERTS")] AllAlerts = 1,
    /// <summary>
    /// Boarding passes will automatically update whenever a change to the departure gate is detected.
    /// </summary>
    [pbr::OriginalName("DEPARTURE_GATE_ALERT")] DepartureGateAlert = 2,
    /// <summary>
    /// Boarding passes will automatically update whenever a change to the estimated departure gate is detected.
    /// </summary>
    [pbr::OriginalName("DEPARTURE_TIME_ALERT")] DepartureTimeAlert = 4,
    /// <summary>
    /// Boarding passes will automatically update whenever a change to the arrival gate is detected.
    /// </summary>
    [pbr::OriginalName("ARRIVAL_GATE_ALERT")] ArrivalGateAlert = 8,
    /// <summary>
    /// Boarding passes will automatically update whenever a change to the estimated arrival time is detected.
    /// </summary>
    [pbr::OriginalName("ARRIVAL_TIME_ALERT")] ArrivalTimeAlert = 16,
    /// <summary>
    /// Boarding passes will automatically update whenever the baggage collection belt or area is known or changes.
    /// </summary>
    [pbr::OriginalName("BAGGAGE_BELT_ALERT")] BaggageBeltAlert = 32,
  }

  /// <summary>
  /// The Boarding Policy is used to determine informational labels on the pass.
  /// </summary>
  public enum BoardingPolicy {
    [pbr::OriginalName("BOARDING_POLICY_UNSPECIFIED")] Unspecified = 0,
    /// <summary>
    /// Boarding is managed by zone.
    /// </summary>
    [pbr::OriginalName("ZONE_BASED")] ZoneBased = 1,
    /// <summary>
    /// Boarding is managed by group.
    /// </summary>
    [pbr::OriginalName("GROUP_BASED")] GroupBased = 2,
    /// <summary>
    /// Another, or No boarding policy is in place.
    /// </summary>
    [pbr::OriginalName("BOARDING_POLICY_OTHER")] Other = 3,
  }

  /// <summary>
  /// The Seat Class Policy is used to determine informational labels on the pass.
  /// </summary>
  public enum SeatClassPolicy {
    [pbr::OriginalName("SEAT_CLASS_POLICY_UNSPECIFIED")] Unspecified = 0,
    /// <summary>
    /// Seats groups are determined by cabin. "Cabin" will be used as the label on the pass.
    /// </summary>
    [pbr::OriginalName("CABIN_BASED")] CabinBased = 1,
    /// <summary>
    /// Seats groups are determined by class of travel. "Class" will be used as the label on the pass.
    /// </summary>
    [pbr::OriginalName("CLASS_BASED")] ClassBased = 2,
    /// <summary>
    /// Seat groups are determined by tier. "Tier" will be used as the label on the pass.
    /// </summary>
    [pbr::OriginalName("TIER_BASED")] TierBased = 3,
    /// <summary>
    /// Another, or no seat policy is in place. No label will be used on the pass.
    /// </summary>
    [pbr::OriginalName("SEAT_CLASS_POLICY_OTHER")] Other = 4,
  }

  /// <summary>
  /// The authority of an identifier (carrier code, airport code, etc.).
  /// </summary>
  public enum Authority {
    /// <summary>
    /// International Air Transport Association (IATA).
    /// </summary>
    [pbr::OriginalName("IATA")] Iata = 0,
    /// <summary>
    /// International Civil Aviation Organization (ICAO).
    /// </summary>
    [pbr::OriginalName("ICAO")] Icao = 1,
  }

  #endregion

  #region Messages
  /// <summary>
  /// carrier code and flight number and valid from represent the primary key.
  /// </summary>
  public sealed partial class FlightDesignator : pb::IMessage<FlightDesignator>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<FlightDesignator> _parser = new pb::MessageParser<FlightDesignator>(() => new FlightDesignator());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<FlightDesignator> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::PassKit.Grpc.Flights.FlightDesignatorReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FlightDesignator() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FlightDesignator(FlightDesignator other) : this() {
      carrierCode_ = other.carrierCode_;
      flightNumber_ = other.flightNumber_;
      validFrom_ = other.validFrom_ != null ? other.validFrom_.Clone() : null;
      revision_ = other.revision_;
      active_ = other.active_;
      schedule_ = other.schedule_ != null ? other.schedule_.Clone() : null;
      operatingCarrierCode_ = other.operatingCarrierCode_;
      operatingFlightNumber_ = other.operatingFlightNumber_;
      codeShareFlightNumbers_ = other.codeShareFlightNumbers_.Clone();
      origin_ = other.origin_;
      destination_ = other.destination_;
      transitPoints_ = other.transitPoints_.Clone();
      departureTerminal_ = other.departureTerminal_;
      arrivalTerminal_ = other.arrivalTerminal_;
      transitTerminals_ = other.transitTerminals_.Clone();
      boardingPolicy_ = other.boardingPolicy_;
      seatClassPolicy_ = other.seatClassPolicy_;
      alerts_ = other.alerts_.Clone();
      passTemplateId_ = other.passTemplateId_;
      autoInvalidateAfter_ = other.autoInvalidateAfter_;
      autoInvalidateCancelledPasses_ = other.autoInvalidateCancelledPasses_;
      locationMessages_ = other.locationMessages_.Clone();
      beaconMessages_ = other.beaconMessages_.Clone();
      defaultLinks_ = other.defaultLinks_.Clone();
      conditionalItems_ = other.conditionalItems_;
      barcodeAdditionalData_ = other.barcodeAdditionalData_;
      invalidateCancelledPasses_ = other.invalidateCancelledPasses_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FlightDesignator Clone() {
      return new FlightDesignator(this);
    }

    /// <summary>Field number for the "carrierCode" field.</summary>
    public const int CarrierCodeFieldNumber = 1;
    private string carrierCode_ = "";
    /// <summary>
    /// The IATA or ICAO carrier code for the flight. In the case of a code-share, this should be the carrier code that you wish to present to the customer. This could be the marketing code, or the operating airline code. A carrier record for this code must exist.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string CarrierCode {
      get { return carrierCode_; }
      set {
        carrierCode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "flightNumber" field.</summary>
    public const int FlightNumberFieldNumber = 2;
    private string flightNumber_ = "";
    /// <summary>
    /// The flight number.  Note this number must match the carrier code.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string FlightNumber {
      get { return flightNumber_; }
      set {
        flightNumber_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "validFrom" field.</summary>
    public const int ValidFromFieldNumber = 3;
    private global::PassKit.Grpc.Date validFrom_;
    /// <summary>
    /// The date that the record is valid from. If not provided, then the date of submission will be used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::PassKit.Grpc.Date ValidFrom {
      get { return validFrom_; }
      set {
        validFrom_ = value;
      }
    }

    /// <summary>Field number for the "revision" field.</summary>
    public const int RevisionFieldNumber = 4;
    private uint revision_;
    /// <summary>
    /// Multiple designators can be active at a time. Provide a revision to distinguish between versions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Revision {
      get { return revision_; }
      set {
        revision_ = value;
      }
    }

    /// <summary>Field number for the "active" field.</summary>
    public const int ActiveFieldNumber = 5;
    private bool active_;
    /// <summary>
    /// Setting to false will prevent further flights to be created against this flight number. Will automatically be set to false if a second designator with a validFrom date before the current date and after this designator's validFrom date is found.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Active {
      get { return active_; }
      set {
        active_ = value;
      }
    }

    /// <summary>Field number for the "schedule" field.</summary>
    public const int ScheduleFieldNumber = 6;
    private global::PassKit.Grpc.Flights.FlightSchedule schedule_;
    /// <summary>
    /// The published flight schedule. If a flight object for a particular departure doesn't exist, these defaults are used. One-off changes to scheduled times for an individual departure should be handled by the Flight object. Long term changes should create a new revision of the FlightDesignator record.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::PassKit.Grpc.Flights.FlightSchedule Schedule {
      get { return schedule_; }
      set {
        schedule_ = value;
      }
    }

    /// <summary>Field number for the "operatingCarrierCode" field.</summary>
    public const int OperatingCarrierCodeFieldNumber = 7;
    private string operatingCarrierCode_ = "";
    /// <summary>
    /// If the flight is operated by a carrier other than the carrierCode supplied, provide the IATA or ICAO carrier code for the operating carrier.  A carrier record must exist.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string OperatingCarrierCode {
      get { return operatingCarrierCode_; }
      set {
        operatingCarrierCode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "operatingFlightNumber" field.</summary>
    public const int OperatingFlightNumberFieldNumber = 8;
    private string operatingFlightNumber_ = "";
    /// <summary>
    /// If the flight is operated by a carrier other than the carrierCode supplied, provide the flight number for the operating carrier.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string OperatingFlightNumber {
      get { return operatingFlightNumber_; }
      set {
        operatingFlightNumber_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "codeShareFlightNumbers" field.</summary>
    public const int CodeShareFlightNumbersFieldNumber = 9;
    private static readonly pb::FieldCodec<string> _repeated_codeShareFlightNumbers_codec
        = pb::FieldCodec.ForString(74);
    private readonly pbc::RepeatedField<string> codeShareFlightNumbers_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// If the flight has code shares, then enter the carrier code and flight number. If there is an operating carrier, then do not include this in the list.  Code share carriers will not be validated.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> CodeShareFlightNumbers {
      get { return codeShareFlightNumbers_; }
    }

    /// <summary>Field number for the "origin" field.</summary>
    public const int OriginFieldNumber = 10;
    private string origin_ = "";
    /// <summary>
    /// The origin port of the flight. In the case of direct flights with multiple stops, this will represent the port where the route commences.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Origin {
      get { return origin_; }
      set {
        origin_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "destination" field.</summary>
    public const int DestinationFieldNumber = 11;
    private string destination_ = "";
    /// <summary>
    /// The destination port of the flight. In the case of direct flights with multiple stops, this will represent the final port where the route terminates.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Destination {
      get { return destination_; }
      set {
        destination_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "transitPoints" field.</summary>
    public const int TransitPointsFieldNumber = 12;
    private static readonly pb::FieldCodec<string> _repeated_transitPoints_codec
        = pb::FieldCodec.ForString(98);
    private readonly pbc::RepeatedField<string> transitPoints_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// In the case of multiple stops, an ordered array of transit points, commencing with the first port after the origin and ending with the penultimate port.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> TransitPoints {
      get { return transitPoints_; }
    }

    /// <summary>Field number for the "departureTerminal" field.</summary>
    public const int DepartureTerminalFieldNumber = 13;
    private string departureTerminal_ = "";
    /// <summary>
    /// The default terminal that the flight departs from.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DepartureTerminal {
      get { return departureTerminal_; }
      set {
        departureTerminal_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "arrivalTerminal" field.</summary>
    public const int ArrivalTerminalFieldNumber = 14;
    private string arrivalTerminal_ = "";
    /// <summary>
    /// The default terminal of the final destination.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ArrivalTerminal {
      get { return arrivalTerminal_; }
      set {
        arrivalTerminal_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "transitTerminals" field.</summary>
    public const int TransitTerminalsFieldNumber = 15;
    private static readonly pb::FieldCodec<string> _repeated_transitTerminals_codec
        = pb::FieldCodec.ForString(122);
    private readonly pbc::RepeatedField<string> transitTerminals_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// In the case of multiple stops, an ordered array of transit terminals. The length of this array should match the number of transit points.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> TransitTerminals {
      get { return transitTerminals_; }
    }

    /// <summary>Field number for the "boardingPolicy" field.</summary>
    public const int BoardingPolicyFieldNumber = 16;
    private global::PassKit.Grpc.Flights.BoardingPolicy boardingPolicy_ = global::PassKit.Grpc.Flights.BoardingPolicy.Unspecified;
    /// <summary>
    /// The Boarding Policy is used to determine informational labels on the pass.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::PassKit.Grpc.Flights.BoardingPolicy BoardingPolicy {
      get { return boardingPolicy_; }
      set {
        boardingPolicy_ = value;
      }
    }

    /// <summary>Field number for the "seatClassPolicy" field.</summary>
    public const int SeatClassPolicyFieldNumber = 17;
    private global::PassKit.Grpc.Flights.SeatClassPolicy seatClassPolicy_ = global::PassKit.Grpc.Flights.SeatClassPolicy.Unspecified;
    /// <summary>
    /// The Seat Class Policy is used to determine informational labels on the pass.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::PassKit.Grpc.Flights.SeatClassPolicy SeatClassPolicy {
      get { return seatClassPolicy_; }
      set {
        seatClassPolicy_ = value;
      }
    }

    /// <summary>Field number for the "alerts" field.</summary>
    public const int AlertsFieldNumber = 18;
    private static readonly pb::FieldCodec<global::PassKit.Grpc.Flights.FlightAlerts> _repeated_alerts_codec
        = pb::FieldCodec.ForEnum(146, x => (int) x, x => (global::PassKit.Grpc.Flights.FlightAlerts) x);
    private readonly pbc::RepeatedField<global::PassKit.Grpc.Flights.FlightAlerts> alerts_ = new pbc::RepeatedField<global::PassKit.Grpc.Flights.FlightAlerts>();
    /// <summary>
    /// An array of alerts to subscribe to for the flight. Note that additional charges apply.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::PassKit.Grpc.Flights.FlightAlerts> Alerts {
      get { return alerts_; }
    }

    /// <summary>Field number for the "passTemplateId" field.</summary>
    public const int PassTemplateIdFieldNumber = 19;
    private string passTemplateId_ = "";
    /// <summary>
    /// The PassKit template id that will be used for boarding passes for this flight. It can be overwritten at the flight level.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PassTemplateId {
      get { return passTemplateId_; }
      set {
        passTemplateId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "autoInvalidateAfter" field.</summary>
    public const int AutoInvalidateAfterFieldNumber = 20;
    private uint autoInvalidateAfter_;
    /// <summary>
    /// Minutes after scheduled arrival time to automatically invalidate the pass. Enter a value of 9999999 or greater if the pass should not auto invalidate. Default is 48 hours.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint AutoInvalidateAfter {
      get { return autoInvalidateAfter_; }
      set {
        autoInvalidateAfter_ = value;
      }
    }

    /// <summary>Field number for the "autoInvalidateCancelledPasses" field.</summary>
    public const int AutoInvalidateCancelledPassesFieldNumber = 21;
    private bool autoInvalidateCancelledPasses_;
    /// <summary>
    /// Deprecated: Use InvalidateCancelledPasses.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool AutoInvalidateCancelledPasses {
      get { return autoInvalidateCancelledPasses_; }
      set {
        autoInvalidateCancelledPasses_ = value;
      }
    }

    /// <summary>Field number for the "locationMessages" field.</summary>
    public const int LocationMessagesFieldNumber = 22;
    private static readonly pb::FieldCodec<global::PassKit.Grpc.GPSLocation> _repeated_locationMessages_codec
        = pb::FieldCodec.ForMessage(178, global::PassKit.Grpc.GPSLocation.Parser);
    private readonly pbc::RepeatedField<global::PassKit.Grpc.GPSLocation> locationMessages_ = new pbc::RepeatedField<global::PassKit.Grpc.GPSLocation>();
    /// <summary>
    /// A list of up to 10 GPS locations where this boarding pass should be presented on the lock-screen.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::PassKit.Grpc.GPSLocation> LocationMessages {
      get { return locationMessages_; }
    }

    /// <summary>Field number for the "beaconMessages" field.</summary>
    public const int BeaconMessagesFieldNumber = 23;
    private static readonly pb::FieldCodec<global::PassKit.Grpc.Beacon> _repeated_beaconMessages_codec
        = pb::FieldCodec.ForMessage(186, global::PassKit.Grpc.Beacon.Parser);
    private readonly pbc::RepeatedField<global::PassKit.Grpc.Beacon> beaconMessages_ = new pbc::RepeatedField<global::PassKit.Grpc.Beacon>();
    /// <summary>
    /// A list of up to 10 Beacon UUIDs that should trigger the boarding pass to be presented on the lock-screen.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::PassKit.Grpc.Beacon> BeaconMessages {
      get { return beaconMessages_; }
    }

    /// <summary>Field number for the "defaultLinks" field.</summary>
    public const int DefaultLinksFieldNumber = 24;
    private static readonly pb::FieldCodec<global::PassKit.Grpc.Link> _repeated_defaultLinks_codec
        = pb::FieldCodec.ForMessage(194, global::PassKit.Grpc.Link.Parser);
    private readonly pbc::RepeatedField<global::PassKit.Grpc.Link> defaultLinks_ = new pbc::RepeatedField<global::PassKit.Grpc.Link>();
    /// <summary>
    /// A list of links to be appended to the end of each boarding pass.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::PassKit.Grpc.Link> DefaultLinks {
      get { return defaultLinks_; }
    }

    /// <summary>Field number for the "ConditionalItems" field.</summary>
    public const int ConditionalItemsFieldNumber = 25;
    private bool conditionalItems_;
    /// <summary>
    /// If PassKit are generating barcodes, include conditional items. Default false.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ConditionalItems {
      get { return conditionalItems_; }
      set {
        conditionalItems_ = value;
      }
    }

    /// <summary>Field number for the "BarcodeAdditionalData" field.</summary>
    public const int BarcodeAdditionalDataFieldNumber = 26;
    private string barcodeAdditionalData_ = "";
    /// <summary>
    /// If PassKit are generating barcodes, default airline use data (IATA item 4). This can be overwritten at the flight and boarding pass level.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string BarcodeAdditionalData {
      get { return barcodeAdditionalData_; }
      set {
        barcodeAdditionalData_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "invalidateCancelledPasses" field.</summary>
    public const int InvalidateCancelledPassesFieldNumber = 27;
    private global::PassKit.Grpc.Toggle invalidateCancelledPasses_ = global::PassKit.Grpc.Toggle.DoNotUse;
    /// <summary>
    /// Invalidate passes where either the booking or the flight have been cancelled. Default is ON.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::PassKit.Grpc.Toggle InvalidateCancelledPasses {
      get { return invalidateCancelledPasses_; }
      set {
        invalidateCancelledPasses_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as FlightDesignator);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(FlightDesignator other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (CarrierCode != other.CarrierCode) return false;
      if (FlightNumber != other.FlightNumber) return false;
      if (!object.Equals(ValidFrom, other.ValidFrom)) return false;
      if (Revision != other.Revision) return false;
      if (Active != other.Active) return false;
      if (!object.Equals(Schedule, other.Schedule)) return false;
      if (OperatingCarrierCode != other.OperatingCarrierCode) return false;
      if (OperatingFlightNumber != other.OperatingFlightNumber) return false;
      if(!codeShareFlightNumbers_.Equals(other.codeShareFlightNumbers_)) return false;
      if (Origin != other.Origin) return false;
      if (Destination != other.Destination) return false;
      if(!transitPoints_.Equals(other.transitPoints_)) return false;
      if (DepartureTerminal != other.DepartureTerminal) return false;
      if (ArrivalTerminal != other.ArrivalTerminal) return false;
      if(!transitTerminals_.Equals(other.transitTerminals_)) return false;
      if (BoardingPolicy != other.BoardingPolicy) return false;
      if (SeatClassPolicy != other.SeatClassPolicy) return false;
      if(!alerts_.Equals(other.alerts_)) return false;
      if (PassTemplateId != other.PassTemplateId) return false;
      if (AutoInvalidateAfter != other.AutoInvalidateAfter) return false;
      if (AutoInvalidateCancelledPasses != other.AutoInvalidateCancelledPasses) return false;
      if(!locationMessages_.Equals(other.locationMessages_)) return false;
      if(!beaconMessages_.Equals(other.beaconMessages_)) return false;
      if(!defaultLinks_.Equals(other.defaultLinks_)) return false;
      if (ConditionalItems != other.ConditionalItems) return false;
      if (BarcodeAdditionalData != other.BarcodeAdditionalData) return false;
      if (InvalidateCancelledPasses != other.InvalidateCancelledPasses) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (CarrierCode.Length != 0) hash ^= CarrierCode.GetHashCode();
      if (FlightNumber.Length != 0) hash ^= FlightNumber.GetHashCode();
      if (validFrom_ != null) hash ^= ValidFrom.GetHashCode();
      if (Revision != 0) hash ^= Revision.GetHashCode();
      if (Active != false) hash ^= Active.GetHashCode();
      if (schedule_ != null) hash ^= Schedule.GetHashCode();
      if (OperatingCarrierCode.Length != 0) hash ^= OperatingCarrierCode.GetHashCode();
      if (OperatingFlightNumber.Length != 0) hash ^= OperatingFlightNumber.GetHashCode();
      hash ^= codeShareFlightNumbers_.GetHashCode();
      if (Origin.Length != 0) hash ^= Origin.GetHashCode();
      if (Destination.Length != 0) hash ^= Destination.GetHashCode();
      hash ^= transitPoints_.GetHashCode();
      if (DepartureTerminal.Length != 0) hash ^= DepartureTerminal.GetHashCode();
      if (ArrivalTerminal.Length != 0) hash ^= ArrivalTerminal.GetHashCode();
      hash ^= transitTerminals_.GetHashCode();
      if (BoardingPolicy != global::PassKit.Grpc.Flights.BoardingPolicy.Unspecified) hash ^= BoardingPolicy.GetHashCode();
      if (SeatClassPolicy != global::PassKit.Grpc.Flights.SeatClassPolicy.Unspecified) hash ^= SeatClassPolicy.GetHashCode();
      hash ^= alerts_.GetHashCode();
      if (PassTemplateId.Length != 0) hash ^= PassTemplateId.GetHashCode();
      if (AutoInvalidateAfter != 0) hash ^= AutoInvalidateAfter.GetHashCode();
      if (AutoInvalidateCancelledPasses != false) hash ^= AutoInvalidateCancelledPasses.GetHashCode();
      hash ^= locationMessages_.GetHashCode();
      hash ^= beaconMessages_.GetHashCode();
      hash ^= defaultLinks_.GetHashCode();
      if (ConditionalItems != false) hash ^= ConditionalItems.GetHashCode();
      if (BarcodeAdditionalData.Length != 0) hash ^= BarcodeAdditionalData.GetHashCode();
      if (InvalidateCancelledPasses != global::PassKit.Grpc.Toggle.DoNotUse) hash ^= InvalidateCancelledPasses.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (CarrierCode.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(CarrierCode);
      }
      if (FlightNumber.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(FlightNumber);
      }
      if (validFrom_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(ValidFrom);
      }
      if (Revision != 0) {
        output.WriteRawTag(32);
        output.WriteUInt32(Revision);
      }
      if (Active != false) {
        output.WriteRawTag(40);
        output.WriteBool(Active);
      }
      if (schedule_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Schedule);
      }
      if (OperatingCarrierCode.Length != 0) {
        output.WriteRawTag(58);
        output.WriteString(OperatingCarrierCode);
      }
      if (OperatingFlightNumber.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(OperatingFlightNumber);
      }
      codeShareFlightNumbers_.WriteTo(output, _repeated_codeShareFlightNumbers_codec);
      if (Origin.Length != 0) {
        output.WriteRawTag(82);
        output.WriteString(Origin);
      }
      if (Destination.Length != 0) {
        output.WriteRawTag(90);
        output.WriteString(Destination);
      }
      transitPoints_.WriteTo(output, _repeated_transitPoints_codec);
      if (DepartureTerminal.Length != 0) {
        output.WriteRawTag(106);
        output.WriteString(DepartureTerminal);
      }
      if (ArrivalTerminal.Length != 0) {
        output.WriteRawTag(114);
        output.WriteString(ArrivalTerminal);
      }
      transitTerminals_.WriteTo(output, _repeated_transitTerminals_codec);
      if (BoardingPolicy != global::PassKit.Grpc.Flights.BoardingPolicy.Unspecified) {
        output.WriteRawTag(128, 1);
        output.WriteEnum((int) BoardingPolicy);
      }
      if (SeatClassPolicy != global::PassKit.Grpc.Flights.SeatClassPolicy.Unspecified) {
        output.WriteRawTag(136, 1);
        output.WriteEnum((int) SeatClassPolicy);
      }
      alerts_.WriteTo(output, _repeated_alerts_codec);
      if (PassTemplateId.Length != 0) {
        output.WriteRawTag(154, 1);
        output.WriteString(PassTemplateId);
      }
      if (AutoInvalidateAfter != 0) {
        output.WriteRawTag(160, 1);
        output.WriteUInt32(AutoInvalidateAfter);
      }
      if (AutoInvalidateCancelledPasses != false) {
        output.WriteRawTag(168, 1);
        output.WriteBool(AutoInvalidateCancelledPasses);
      }
      locationMessages_.WriteTo(output, _repeated_locationMessages_codec);
      beaconMessages_.WriteTo(output, _repeated_beaconMessages_codec);
      defaultLinks_.WriteTo(output, _repeated_defaultLinks_codec);
      if (ConditionalItems != false) {
        output.WriteRawTag(200, 1);
        output.WriteBool(ConditionalItems);
      }
      if (BarcodeAdditionalData.Length != 0) {
        output.WriteRawTag(210, 1);
        output.WriteString(BarcodeAdditionalData);
      }
      if (InvalidateCancelledPasses != global::PassKit.Grpc.Toggle.DoNotUse) {
        output.WriteRawTag(216, 1);
        output.WriteEnum((int) InvalidateCancelledPasses);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (CarrierCode.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(CarrierCode);
      }
      if (FlightNumber.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(FlightNumber);
      }
      if (validFrom_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(ValidFrom);
      }
      if (Revision != 0) {
        output.WriteRawTag(32);
        output.WriteUInt32(Revision);
      }
      if (Active != false) {
        output.WriteRawTag(40);
        output.WriteBool(Active);
      }
      if (schedule_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Schedule);
      }
      if (OperatingCarrierCode.Length != 0) {
        output.WriteRawTag(58);
        output.WriteString(OperatingCarrierCode);
      }
      if (OperatingFlightNumber.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(OperatingFlightNumber);
      }
      codeShareFlightNumbers_.WriteTo(ref output, _repeated_codeShareFlightNumbers_codec);
      if (Origin.Length != 0) {
        output.WriteRawTag(82);
        output.WriteString(Origin);
      }
      if (Destination.Length != 0) {
        output.WriteRawTag(90);
        output.WriteString(Destination);
      }
      transitPoints_.WriteTo(ref output, _repeated_transitPoints_codec);
      if (DepartureTerminal.Length != 0) {
        output.WriteRawTag(106);
        output.WriteString(DepartureTerminal);
      }
      if (ArrivalTerminal.Length != 0) {
        output.WriteRawTag(114);
        output.WriteString(ArrivalTerminal);
      }
      transitTerminals_.WriteTo(ref output, _repeated_transitTerminals_codec);
      if (BoardingPolicy != global::PassKit.Grpc.Flights.BoardingPolicy.Unspecified) {
        output.WriteRawTag(128, 1);
        output.WriteEnum((int) BoardingPolicy);
      }
      if (SeatClassPolicy != global::PassKit.Grpc.Flights.SeatClassPolicy.Unspecified) {
        output.WriteRawTag(136, 1);
        output.WriteEnum((int) SeatClassPolicy);
      }
      alerts_.WriteTo(ref output, _repeated_alerts_codec);
      if (PassTemplateId.Length != 0) {
        output.WriteRawTag(154, 1);
        output.WriteString(PassTemplateId);
      }
      if (AutoInvalidateAfter != 0) {
        output.WriteRawTag(160, 1);
        output.WriteUInt32(AutoInvalidateAfter);
      }
      if (AutoInvalidateCancelledPasses != false) {
        output.WriteRawTag(168, 1);
        output.WriteBool(AutoInvalidateCancelledPasses);
      }
      locationMessages_.WriteTo(ref output, _repeated_locationMessages_codec);
      beaconMessages_.WriteTo(ref output, _repeated_beaconMessages_codec);
      defaultLinks_.WriteTo(ref output, _repeated_defaultLinks_codec);
      if (ConditionalItems != false) {
        output.WriteRawTag(200, 1);
        output.WriteBool(ConditionalItems);
      }
      if (BarcodeAdditionalData.Length != 0) {
        output.WriteRawTag(210, 1);
        output.WriteString(BarcodeAdditionalData);
      }
      if (InvalidateCancelledPasses != global::PassKit.Grpc.Toggle.DoNotUse) {
        output.WriteRawTag(216, 1);
        output.WriteEnum((int) InvalidateCancelledPasses);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (CarrierCode.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(CarrierCode);
      }
      if (FlightNumber.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FlightNumber);
      }
      if (validFrom_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ValidFrom);
      }
      if (Revision != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Revision);
      }
      if (Active != false) {
        size += 1 + 1;
      }
      if (schedule_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Schedule);
      }
      if (OperatingCarrierCode.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(OperatingCarrierCode);
      }
      if (OperatingFlightNumber.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(OperatingFlightNumber);
      }
      size += codeShareFlightNumbers_.CalculateSize(_repeated_codeShareFlightNumbers_codec);
      if (Origin.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Origin);
      }
      if (Destination.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Destination);
      }
      size += transitPoints_.CalculateSize(_repeated_transitPoints_codec);
      if (DepartureTerminal.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DepartureTerminal);
      }
      if (ArrivalTerminal.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ArrivalTerminal);
      }
      size += transitTerminals_.CalculateSize(_repeated_transitTerminals_codec);
      if (BoardingPolicy != global::PassKit.Grpc.Flights.BoardingPolicy.Unspecified) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) BoardingPolicy);
      }
      if (SeatClassPolicy != global::PassKit.Grpc.Flights.SeatClassPolicy.Unspecified) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) SeatClassPolicy);
      }
      size += alerts_.CalculateSize(_repeated_alerts_codec);
      if (PassTemplateId.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(PassTemplateId);
      }
      if (AutoInvalidateAfter != 0) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(AutoInvalidateAfter);
      }
      if (AutoInvalidateCancelledPasses != false) {
        size += 2 + 1;
      }
      size += locationMessages_.CalculateSize(_repeated_locationMessages_codec);
      size += beaconMessages_.CalculateSize(_repeated_beaconMessages_codec);
      size += defaultLinks_.CalculateSize(_repeated_defaultLinks_codec);
      if (ConditionalItems != false) {
        size += 2 + 1;
      }
      if (BarcodeAdditionalData.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(BarcodeAdditionalData);
      }
      if (InvalidateCancelledPasses != global::PassKit.Grpc.Toggle.DoNotUse) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) InvalidateCancelledPasses);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(FlightDesignator other) {
      if (other == null) {
        return;
      }
      if (other.CarrierCode.Length != 0) {
        CarrierCode = other.CarrierCode;
      }
      if (other.FlightNumber.Length != 0) {
        FlightNumber = other.FlightNumber;
      }
      if (other.validFrom_ != null) {
        if (validFrom_ == null) {
          ValidFrom = new global::PassKit.Grpc.Date();
        }
        ValidFrom.MergeFrom(other.ValidFrom);
      }
      if (other.Revision != 0) {
        Revision = other.Revision;
      }
      if (other.Active != false) {
        Active = other.Active;
      }
      if (other.schedule_ != null) {
        if (schedule_ == null) {
          Schedule = new global::PassKit.Grpc.Flights.FlightSchedule();
        }
        Schedule.MergeFrom(other.Schedule);
      }
      if (other.OperatingCarrierCode.Length != 0) {
        OperatingCarrierCode = other.OperatingCarrierCode;
      }
      if (other.OperatingFlightNumber.Length != 0) {
        OperatingFlightNumber = other.OperatingFlightNumber;
      }
      codeShareFlightNumbers_.Add(other.codeShareFlightNumbers_);
      if (other.Origin.Length != 0) {
        Origin = other.Origin;
      }
      if (other.Destination.Length != 0) {
        Destination = other.Destination;
      }
      transitPoints_.Add(other.transitPoints_);
      if (other.DepartureTerminal.Length != 0) {
        DepartureTerminal = other.DepartureTerminal;
      }
      if (other.ArrivalTerminal.Length != 0) {
        ArrivalTerminal = other.ArrivalTerminal;
      }
      transitTerminals_.Add(other.transitTerminals_);
      if (other.BoardingPolicy != global::PassKit.Grpc.Flights.BoardingPolicy.Unspecified) {
        BoardingPolicy = other.BoardingPolicy;
      }
      if (other.SeatClassPolicy != global::PassKit.Grpc.Flights.SeatClassPolicy.Unspecified) {
        SeatClassPolicy = other.SeatClassPolicy;
      }
      alerts_.Add(other.alerts_);
      if (other.PassTemplateId.Length != 0) {
        PassTemplateId = other.PassTemplateId;
      }
      if (other.AutoInvalidateAfter != 0) {
        AutoInvalidateAfter = other.AutoInvalidateAfter;
      }
      if (other.AutoInvalidateCancelledPasses != false) {
        AutoInvalidateCancelledPasses = other.AutoInvalidateCancelledPasses;
      }
      locationMessages_.Add(other.locationMessages_);
      beaconMessages_.Add(other.beaconMessages_);
      defaultLinks_.Add(other.defaultLinks_);
      if (other.ConditionalItems != false) {
        ConditionalItems = other.ConditionalItems;
      }
      if (other.BarcodeAdditionalData.Length != 0) {
        BarcodeAdditionalData = other.BarcodeAdditionalData;
      }
      if (other.InvalidateCancelledPasses != global::PassKit.Grpc.Toggle.DoNotUse) {
        InvalidateCancelledPasses = other.InvalidateCancelledPasses;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            CarrierCode = input.ReadString();
            break;
          }
          case 18: {
            FlightNumber = input.ReadString();
            break;
          }
          case 26: {
            if (validFrom_ == null) {
              ValidFrom = new global::PassKit.Grpc.Date();
            }
            input.ReadMessage(ValidFrom);
            break;
          }
          case 32: {
            Revision = input.ReadUInt32();
            break;
          }
          case 40: {
            Active = input.ReadBool();
            break;
          }
          case 50: {
            if (schedule_ == null) {
              Schedule = new global::PassKit.Grpc.Flights.FlightSchedule();
            }
            input.ReadMessage(Schedule);
            break;
          }
          case 58: {
            OperatingCarrierCode = input.ReadString();
            break;
          }
          case 66: {
            OperatingFlightNumber = input.ReadString();
            break;
          }
          case 74: {
            codeShareFlightNumbers_.AddEntriesFrom(input, _repeated_codeShareFlightNumbers_codec);
            break;
          }
          case 82: {
            Origin = input.ReadString();
            break;
          }
          case 90: {
            Destination = input.ReadString();
            break;
          }
          case 98: {
            transitPoints_.AddEntriesFrom(input, _repeated_transitPoints_codec);
            break;
          }
          case 106: {
            DepartureTerminal = input.ReadString();
            break;
          }
          case 114: {
            ArrivalTerminal = input.ReadString();
            break;
          }
          case 122: {
            transitTerminals_.AddEntriesFrom(input, _repeated_transitTerminals_codec);
            break;
          }
          case 128: {
            BoardingPolicy = (global::PassKit.Grpc.Flights.BoardingPolicy) input.ReadEnum();
            break;
          }
          case 136: {
            SeatClassPolicy = (global::PassKit.Grpc.Flights.SeatClassPolicy) input.ReadEnum();
            break;
          }
          case 146:
          case 144: {
            alerts_.AddEntriesFrom(input, _repeated_alerts_codec);
            break;
          }
          case 154: {
            PassTemplateId = input.ReadString();
            break;
          }
          case 160: {
            AutoInvalidateAfter = input.ReadUInt32();
            break;
          }
          case 168: {
            AutoInvalidateCancelledPasses = input.ReadBool();
            break;
          }
          case 178: {
            locationMessages_.AddEntriesFrom(input, _repeated_locationMessages_codec);
            break;
          }
          case 186: {
            beaconMessages_.AddEntriesFrom(input, _repeated_beaconMessages_codec);
            break;
          }
          case 194: {
            defaultLinks_.AddEntriesFrom(input, _repeated_defaultLinks_codec);
            break;
          }
          case 200: {
            ConditionalItems = input.ReadBool();
            break;
          }
          case 210: {
            BarcodeAdditionalData = input.ReadString();
            break;
          }
          case 216: {
            InvalidateCancelledPasses = (global::PassKit.Grpc.Toggle) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            CarrierCode = input.ReadString();
            break;
          }
          case 18: {
            FlightNumber = input.ReadString();
            break;
          }
          case 26: {
            if (validFrom_ == null) {
              ValidFrom = new global::PassKit.Grpc.Date();
            }
            input.ReadMessage(ValidFrom);
            break;
          }
          case 32: {
            Revision = input.ReadUInt32();
            break;
          }
          case 40: {
            Active = input.ReadBool();
            break;
          }
          case 50: {
            if (schedule_ == null) {
              Schedule = new global::PassKit.Grpc.Flights.FlightSchedule();
            }
            input.ReadMessage(Schedule);
            break;
          }
          case 58: {
            OperatingCarrierCode = input.ReadString();
            break;
          }
          case 66: {
            OperatingFlightNumber = input.ReadString();
            break;
          }
          case 74: {
            codeShareFlightNumbers_.AddEntriesFrom(ref input, _repeated_codeShareFlightNumbers_codec);
            break;
          }
          case 82: {
            Origin = input.ReadString();
            break;
          }
          case 90: {
            Destination = input.ReadString();
            break;
          }
          case 98: {
            transitPoints_.AddEntriesFrom(ref input, _repeated_transitPoints_codec);
            break;
          }
          case 106: {
            DepartureTerminal = input.ReadString();
            break;
          }
          case 114: {
            ArrivalTerminal = input.ReadString();
            break;
          }
          case 122: {
            transitTerminals_.AddEntriesFrom(ref input, _repeated_transitTerminals_codec);
            break;
          }
          case 128: {
            BoardingPolicy = (global::PassKit.Grpc.Flights.BoardingPolicy) input.ReadEnum();
            break;
          }
          case 136: {
            SeatClassPolicy = (global::PassKit.Grpc.Flights.SeatClassPolicy) input.ReadEnum();
            break;
          }
          case 146:
          case 144: {
            alerts_.AddEntriesFrom(ref input, _repeated_alerts_codec);
            break;
          }
          case 154: {
            PassTemplateId = input.ReadString();
            break;
          }
          case 160: {
            AutoInvalidateAfter = input.ReadUInt32();
            break;
          }
          case 168: {
            AutoInvalidateCancelledPasses = input.ReadBool();
            break;
          }
          case 178: {
            locationMessages_.AddEntriesFrom(ref input, _repeated_locationMessages_codec);
            break;
          }
          case 186: {
            beaconMessages_.AddEntriesFrom(ref input, _repeated_beaconMessages_codec);
            break;
          }
          case 194: {
            defaultLinks_.AddEntriesFrom(ref input, _repeated_defaultLinks_codec);
            break;
          }
          case 200: {
            ConditionalItems = input.ReadBool();
            break;
          }
          case 210: {
            BarcodeAdditionalData = input.ReadString();
            break;
          }
          case 216: {
            InvalidateCancelledPasses = (global::PassKit.Grpc.Toggle) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class FlightDesignatorRequest : pb::IMessage<FlightDesignatorRequest>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<FlightDesignatorRequest> _parser = new pb::MessageParser<FlightDesignatorRequest>(() => new FlightDesignatorRequest());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<FlightDesignatorRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::PassKit.Grpc.Flights.FlightDesignatorReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FlightDesignatorRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FlightDesignatorRequest(FlightDesignatorRequest other) : this() {
      carrierCode_ = other.carrierCode_;
      flightNumber_ = other.flightNumber_;
      revision_ = other.revision_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FlightDesignatorRequest Clone() {
      return new FlightDesignatorRequest(this);
    }

    /// <summary>Field number for the "carrierCode" field.</summary>
    public const int CarrierCodeFieldNumber = 1;
    private string carrierCode_ = "";
    /// <summary>
    /// The IATA or ICAO carrier code for the flight.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string CarrierCode {
      get { return carrierCode_; }
      set {
        carrierCode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "flightNumber" field.</summary>
    public const int FlightNumberFieldNumber = 2;
    private string flightNumber_ = "";
    /// <summary>
    /// The flight number.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string FlightNumber {
      get { return flightNumber_; }
      set {
        flightNumber_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "revision" field.</summary>
    public const int RevisionFieldNumber = 3;
    private uint revision_;
    /// <summary>
    /// Revision. Each designator record requires a version number.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Revision {
      get { return revision_; }
      set {
        revision_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as FlightDesignatorRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(FlightDesignatorRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (CarrierCode != other.CarrierCode) return false;
      if (FlightNumber != other.FlightNumber) return false;
      if (Revision != other.Revision) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (CarrierCode.Length != 0) hash ^= CarrierCode.GetHashCode();
      if (FlightNumber.Length != 0) hash ^= FlightNumber.GetHashCode();
      if (Revision != 0) hash ^= Revision.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (CarrierCode.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(CarrierCode);
      }
      if (FlightNumber.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(FlightNumber);
      }
      if (Revision != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(Revision);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (CarrierCode.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(CarrierCode);
      }
      if (FlightNumber.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(FlightNumber);
      }
      if (Revision != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(Revision);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (CarrierCode.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(CarrierCode);
      }
      if (FlightNumber.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FlightNumber);
      }
      if (Revision != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Revision);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(FlightDesignatorRequest other) {
      if (other == null) {
        return;
      }
      if (other.CarrierCode.Length != 0) {
        CarrierCode = other.CarrierCode;
      }
      if (other.FlightNumber.Length != 0) {
        FlightNumber = other.FlightNumber;
      }
      if (other.Revision != 0) {
        Revision = other.Revision;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            CarrierCode = input.ReadString();
            break;
          }
          case 18: {
            FlightNumber = input.ReadString();
            break;
          }
          case 24: {
            Revision = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            CarrierCode = input.ReadString();
            break;
          }
          case 18: {
            FlightNumber = input.ReadString();
            break;
          }
          case 24: {
            Revision = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// If there are no departures on a given day (E.g. flight only operates on Tuesdays and Thursdays), the days with no departures should be nil.
  /// </summary>
  public sealed partial class FlightSchedule : pb::IMessage<FlightSchedule>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<FlightSchedule> _parser = new pb::MessageParser<FlightSchedule>(() => new FlightSchedule());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<FlightSchedule> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::PassKit.Grpc.Flights.FlightDesignatorReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FlightSchedule() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FlightSchedule(FlightSchedule other) : this() {
      monday_ = other.monday_ != null ? other.monday_.Clone() : null;
      tuesday_ = other.tuesday_ != null ? other.tuesday_.Clone() : null;
      wednesday_ = other.wednesday_ != null ? other.wednesday_.Clone() : null;
      thursday_ = other.thursday_ != null ? other.thursday_.Clone() : null;
      friday_ = other.friday_ != null ? other.friday_.Clone() : null;
      saturday_ = other.saturday_ != null ? other.saturday_.Clone() : null;
      sunday_ = other.sunday_ != null ? other.sunday_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FlightSchedule Clone() {
      return new FlightSchedule(this);
    }

    /// <summary>Field number for the "monday" field.</summary>
    public const int MondayFieldNumber = 1;
    private global::PassKit.Grpc.Flights.FlightTimes monday_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::PassKit.Grpc.Flights.FlightTimes Monday {
      get { return monday_; }
      set {
        monday_ = value;
      }
    }

    /// <summary>Field number for the "tuesday" field.</summary>
    public const int TuesdayFieldNumber = 2;
    private global::PassKit.Grpc.Flights.FlightTimes tuesday_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::PassKit.Grpc.Flights.FlightTimes Tuesday {
      get { return tuesday_; }
      set {
        tuesday_ = value;
      }
    }

    /// <summary>Field number for the "wednesday" field.</summary>
    public const int WednesdayFieldNumber = 3;
    private global::PassKit.Grpc.Flights.FlightTimes wednesday_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::PassKit.Grpc.Flights.FlightTimes Wednesday {
      get { return wednesday_; }
      set {
        wednesday_ = value;
      }
    }

    /// <summary>Field number for the "thursday" field.</summary>
    public const int ThursdayFieldNumber = 4;
    private global::PassKit.Grpc.Flights.FlightTimes thursday_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::PassKit.Grpc.Flights.FlightTimes Thursday {
      get { return thursday_; }
      set {
        thursday_ = value;
      }
    }

    /// <summary>Field number for the "friday" field.</summary>
    public const int FridayFieldNumber = 5;
    private global::PassKit.Grpc.Flights.FlightTimes friday_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::PassKit.Grpc.Flights.FlightTimes Friday {
      get { return friday_; }
      set {
        friday_ = value;
      }
    }

    /// <summary>Field number for the "saturday" field.</summary>
    public const int SaturdayFieldNumber = 6;
    private global::PassKit.Grpc.Flights.FlightTimes saturday_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::PassKit.Grpc.Flights.FlightTimes Saturday {
      get { return saturday_; }
      set {
        saturday_ = value;
      }
    }

    /// <summary>Field number for the "sunday" field.</summary>
    public const int SundayFieldNumber = 7;
    private global::PassKit.Grpc.Flights.FlightTimes sunday_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::PassKit.Grpc.Flights.FlightTimes Sunday {
      get { return sunday_; }
      set {
        sunday_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as FlightSchedule);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(FlightSchedule other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Monday, other.Monday)) return false;
      if (!object.Equals(Tuesday, other.Tuesday)) return false;
      if (!object.Equals(Wednesday, other.Wednesday)) return false;
      if (!object.Equals(Thursday, other.Thursday)) return false;
      if (!object.Equals(Friday, other.Friday)) return false;
      if (!object.Equals(Saturday, other.Saturday)) return false;
      if (!object.Equals(Sunday, other.Sunday)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (monday_ != null) hash ^= Monday.GetHashCode();
      if (tuesday_ != null) hash ^= Tuesday.GetHashCode();
      if (wednesday_ != null) hash ^= Wednesday.GetHashCode();
      if (thursday_ != null) hash ^= Thursday.GetHashCode();
      if (friday_ != null) hash ^= Friday.GetHashCode();
      if (saturday_ != null) hash ^= Saturday.GetHashCode();
      if (sunday_ != null) hash ^= Sunday.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (monday_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Monday);
      }
      if (tuesday_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Tuesday);
      }
      if (wednesday_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Wednesday);
      }
      if (thursday_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Thursday);
      }
      if (friday_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Friday);
      }
      if (saturday_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Saturday);
      }
      if (sunday_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Sunday);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (monday_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Monday);
      }
      if (tuesday_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Tuesday);
      }
      if (wednesday_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Wednesday);
      }
      if (thursday_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(Thursday);
      }
      if (friday_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Friday);
      }
      if (saturday_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Saturday);
      }
      if (sunday_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Sunday);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (monday_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Monday);
      }
      if (tuesday_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Tuesday);
      }
      if (wednesday_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Wednesday);
      }
      if (thursday_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Thursday);
      }
      if (friday_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Friday);
      }
      if (saturday_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Saturday);
      }
      if (sunday_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Sunday);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(FlightSchedule other) {
      if (other == null) {
        return;
      }
      if (other.monday_ != null) {
        if (monday_ == null) {
          Monday = new global::PassKit.Grpc.Flights.FlightTimes();
        }
        Monday.MergeFrom(other.Monday);
      }
      if (other.tuesday_ != null) {
        if (tuesday_ == null) {
          Tuesday = new global::PassKit.Grpc.Flights.FlightTimes();
        }
        Tuesday.MergeFrom(other.Tuesday);
      }
      if (other.wednesday_ != null) {
        if (wednesday_ == null) {
          Wednesday = new global::PassKit.Grpc.Flights.FlightTimes();
        }
        Wednesday.MergeFrom(other.Wednesday);
      }
      if (other.thursday_ != null) {
        if (thursday_ == null) {
          Thursday = new global::PassKit.Grpc.Flights.FlightTimes();
        }
        Thursday.MergeFrom(other.Thursday);
      }
      if (other.friday_ != null) {
        if (friday_ == null) {
          Friday = new global::PassKit.Grpc.Flights.FlightTimes();
        }
        Friday.MergeFrom(other.Friday);
      }
      if (other.saturday_ != null) {
        if (saturday_ == null) {
          Saturday = new global::PassKit.Grpc.Flights.FlightTimes();
        }
        Saturday.MergeFrom(other.Saturday);
      }
      if (other.sunday_ != null) {
        if (sunday_ == null) {
          Sunday = new global::PassKit.Grpc.Flights.FlightTimes();
        }
        Sunday.MergeFrom(other.Sunday);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (monday_ == null) {
              Monday = new global::PassKit.Grpc.Flights.FlightTimes();
            }
            input.ReadMessage(Monday);
            break;
          }
          case 18: {
            if (tuesday_ == null) {
              Tuesday = new global::PassKit.Grpc.Flights.FlightTimes();
            }
            input.ReadMessage(Tuesday);
            break;
          }
          case 26: {
            if (wednesday_ == null) {
              Wednesday = new global::PassKit.Grpc.Flights.FlightTimes();
            }
            input.ReadMessage(Wednesday);
            break;
          }
          case 34: {
            if (thursday_ == null) {
              Thursday = new global::PassKit.Grpc.Flights.FlightTimes();
            }
            input.ReadMessage(Thursday);
            break;
          }
          case 42: {
            if (friday_ == null) {
              Friday = new global::PassKit.Grpc.Flights.FlightTimes();
            }
            input.ReadMessage(Friday);
            break;
          }
          case 50: {
            if (saturday_ == null) {
              Saturday = new global::PassKit.Grpc.Flights.FlightTimes();
            }
            input.ReadMessage(Saturday);
            break;
          }
          case 58: {
            if (sunday_ == null) {
              Sunday = new global::PassKit.Grpc.Flights.FlightTimes();
            }
            input.ReadMessage(Sunday);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (monday_ == null) {
              Monday = new global::PassKit.Grpc.Flights.FlightTimes();
            }
            input.ReadMessage(Monday);
            break;
          }
          case 18: {
            if (tuesday_ == null) {
              Tuesday = new global::PassKit.Grpc.Flights.FlightTimes();
            }
            input.ReadMessage(Tuesday);
            break;
          }
          case 26: {
            if (wednesday_ == null) {
              Wednesday = new global::PassKit.Grpc.Flights.FlightTimes();
            }
            input.ReadMessage(Wednesday);
            break;
          }
          case 34: {
            if (thursday_ == null) {
              Thursday = new global::PassKit.Grpc.Flights.FlightTimes();
            }
            input.ReadMessage(Thursday);
            break;
          }
          case 42: {
            if (friday_ == null) {
              Friday = new global::PassKit.Grpc.Flights.FlightTimes();
            }
            input.ReadMessage(Friday);
            break;
          }
          case 50: {
            if (saturday_ == null) {
              Saturday = new global::PassKit.Grpc.Flights.FlightTimes();
            }
            input.ReadMessage(Saturday);
            break;
          }
          case 58: {
            if (sunday_ == null) {
              Sunday = new global::PassKit.Grpc.Flights.FlightTimes();
            }
            input.ReadMessage(Sunday);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class FlightTimes : pb::IMessage<FlightTimes>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<FlightTimes> _parser = new pb::MessageParser<FlightTimes>(() => new FlightTimes());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<FlightTimes> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::PassKit.Grpc.Flights.FlightDesignatorReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FlightTimes() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FlightTimes(FlightTimes other) : this() {
      scheduledDepartureTime_ = other.scheduledDepartureTime_ != null ? other.scheduledDepartureTime_.Clone() : null;
      boardingTime_ = other.boardingTime_ != null ? other.boardingTime_.Clone() : null;
      gateClosingTime_ = other.gateClosingTime_ != null ? other.gateClosingTime_.Clone() : null;
      scheduledArrivalTime_ = other.scheduledArrivalTime_ != null ? other.scheduledArrivalTime_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FlightTimes Clone() {
      return new FlightTimes(this);
    }

    /// <summary>Field number for the "scheduledDepartureTime" field.</summary>
    public const int ScheduledDepartureTimeFieldNumber = 1;
    private global::PassKit.Grpc.Time scheduledDepartureTime_;
    /// <summary>
    /// The published departure time.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::PassKit.Grpc.Time ScheduledDepartureTime {
      get { return scheduledDepartureTime_; }
      set {
        scheduledDepartureTime_ = value;
      }
    }

    /// <summary>Field number for the "boardingTime" field.</summary>
    public const int BoardingTimeFieldNumber = 2;
    private global::PassKit.Grpc.Time boardingTime_;
    /// <summary>
    /// The published boarding time.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::PassKit.Grpc.Time BoardingTime {
      get { return boardingTime_; }
      set {
        boardingTime_ = value;
      }
    }

    /// <summary>Field number for the "gateClosingTime" field.</summary>
    public const int GateClosingTimeFieldNumber = 3;
    private global::PassKit.Grpc.Time gateClosingTime_;
    /// <summary>
    /// The point after which passengers will be denied boarding.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::PassKit.Grpc.Time GateClosingTime {
      get { return gateClosingTime_; }
      set {
        gateClosingTime_ = value;
      }
    }

    /// <summary>Field number for the "scheduledArrivalTime" field.</summary>
    public const int ScheduledArrivalTimeFieldNumber = 4;
    private global::PassKit.Grpc.Time scheduledArrivalTime_;
    /// <summary>
    /// The published, scheduled arrival time.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::PassKit.Grpc.Time ScheduledArrivalTime {
      get { return scheduledArrivalTime_; }
      set {
        scheduledArrivalTime_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as FlightTimes);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(FlightTimes other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(ScheduledDepartureTime, other.ScheduledDepartureTime)) return false;
      if (!object.Equals(BoardingTime, other.BoardingTime)) return false;
      if (!object.Equals(GateClosingTime, other.GateClosingTime)) return false;
      if (!object.Equals(ScheduledArrivalTime, other.ScheduledArrivalTime)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (scheduledDepartureTime_ != null) hash ^= ScheduledDepartureTime.GetHashCode();
      if (boardingTime_ != null) hash ^= BoardingTime.GetHashCode();
      if (gateClosingTime_ != null) hash ^= GateClosingTime.GetHashCode();
      if (scheduledArrivalTime_ != null) hash ^= ScheduledArrivalTime.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (scheduledDepartureTime_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ScheduledDepartureTime);
      }
      if (boardingTime_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(BoardingTime);
      }
      if (gateClosingTime_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(GateClosingTime);
      }
      if (scheduledArrivalTime_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(ScheduledArrivalTime);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (scheduledDepartureTime_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ScheduledDepartureTime);
      }
      if (boardingTime_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(BoardingTime);
      }
      if (gateClosingTime_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(GateClosingTime);
      }
      if (scheduledArrivalTime_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(ScheduledArrivalTime);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (scheduledDepartureTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ScheduledDepartureTime);
      }
      if (boardingTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(BoardingTime);
      }
      if (gateClosingTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(GateClosingTime);
      }
      if (scheduledArrivalTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ScheduledArrivalTime);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(FlightTimes other) {
      if (other == null) {
        return;
      }
      if (other.scheduledDepartureTime_ != null) {
        if (scheduledDepartureTime_ == null) {
          ScheduledDepartureTime = new global::PassKit.Grpc.Time();
        }
        ScheduledDepartureTime.MergeFrom(other.ScheduledDepartureTime);
      }
      if (other.boardingTime_ != null) {
        if (boardingTime_ == null) {
          BoardingTime = new global::PassKit.Grpc.Time();
        }
        BoardingTime.MergeFrom(other.BoardingTime);
      }
      if (other.gateClosingTime_ != null) {
        if (gateClosingTime_ == null) {
          GateClosingTime = new global::PassKit.Grpc.Time();
        }
        GateClosingTime.MergeFrom(other.GateClosingTime);
      }
      if (other.scheduledArrivalTime_ != null) {
        if (scheduledArrivalTime_ == null) {
          ScheduledArrivalTime = new global::PassKit.Grpc.Time();
        }
        ScheduledArrivalTime.MergeFrom(other.ScheduledArrivalTime);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (scheduledDepartureTime_ == null) {
              ScheduledDepartureTime = new global::PassKit.Grpc.Time();
            }
            input.ReadMessage(ScheduledDepartureTime);
            break;
          }
          case 18: {
            if (boardingTime_ == null) {
              BoardingTime = new global::PassKit.Grpc.Time();
            }
            input.ReadMessage(BoardingTime);
            break;
          }
          case 26: {
            if (gateClosingTime_ == null) {
              GateClosingTime = new global::PassKit.Grpc.Time();
            }
            input.ReadMessage(GateClosingTime);
            break;
          }
          case 34: {
            if (scheduledArrivalTime_ == null) {
              ScheduledArrivalTime = new global::PassKit.Grpc.Time();
            }
            input.ReadMessage(ScheduledArrivalTime);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (scheduledDepartureTime_ == null) {
              ScheduledDepartureTime = new global::PassKit.Grpc.Time();
            }
            input.ReadMessage(ScheduledDepartureTime);
            break;
          }
          case 18: {
            if (boardingTime_ == null) {
              BoardingTime = new global::PassKit.Grpc.Time();
            }
            input.ReadMessage(BoardingTime);
            break;
          }
          case 26: {
            if (gateClosingTime_ == null) {
              GateClosingTime = new global::PassKit.Grpc.Time();
            }
            input.ReadMessage(GateClosingTime);
            break;
          }
          case 34: {
            if (scheduledArrivalTime_ == null) {
              ScheduledArrivalTime = new global::PassKit.Grpc.Time();
            }
            input.ReadMessage(ScheduledArrivalTime);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
