// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: io/common/expiry.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace PKIo {

  /// <summary>Holder for reflection information generated from io/common/expiry.proto</summary>
  public static partial class ExpiryReflection {

    #region Descriptor
    /// <summary>File descriptor for io/common/expiry.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ExpiryReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChZpby9jb21tb24vZXhwaXJ5LnByb3RvEgJpbxoeaW8vY29tbW9uL2NvbW1v",
            "bl9vYmplY3RzLnByb3RvIoQBCg5FeHBpcnlTZXR0aW5ncxIiCgpleHBpcnlU",
            "eXBlGAEgASgOMg4uaW8uRXhwaXJ5VHlwZRIjCg9maXhlZEV4cGlyeURhdGUY",
            "AiABKAsyCC5pby5EYXRlSAASGgoQZXhwaXJlQWZ0ZXJYRGF5cxgDIAEoDUgA",
            "Qg0KC2V4cGlyeU9uZW9mKooBCgpFeHBpcnlUeXBlEg8KC0VYUElSRV9OT05F",
            "EAASGAoURVhQSVJFX09OX0ZJWEVEX0RBVEUQARIXChNFWFBJUkVfQUZURVJf",
            "WF9EQVlTEAISIAocRVhQSVJFX09OX1ZBUklBQkxFX0RBVEVfVElNRRADEhYK",
            "EkVYUElSRV9TRVRfVE9fTlVMTBAEQj4KD2lvLnBhc3NraXQuUEtpb1okc3Rh",
            "c2gucGFzc2tpdC5jb20vaW8vbW9kZWwvc2RrL2dvL2lvqgIEUEtJb2IGcHJv",
            "dG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::PKIo.CommonObjectsReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::PKIo.ExpiryType), }, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::PKIo.ExpirySettings), global::PKIo.ExpirySettings.Parser, new[]{ "ExpiryType", "FixedExpiryDate", "ExpireAfterXDays" }, new[]{ "ExpiryOneof" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// Options to manage the expiry date of the digital card.
  /// </summary>
  public enum ExpiryType {
    /// <summary>
    /// Please do not use this enum. This enum do not have any effect on expiry logic.
    /// </summary>
    [pbr::OriginalName("EXPIRE_NONE")] ExpireNone = 0,
    /// <summary>
    /// Expiry date is set with year, month and date. The expiry date will be based on your timezone. The digital card will expire at 23:59:59:59.99999 of set date in fixed timezone. The expiry date is the same for all cards.
    /// </summary>
    [pbr::OriginalName("EXPIRE_ON_FIXED_DATE")] ExpireOnFixedDate = 1,
    /// <summary>
    /// The digital card expires after the number of days after the digital card issuing.
    /// </summary>
    [pbr::OriginalName("EXPIRE_AFTER_X_DAYS")] ExpireAfterXDays = 2,
    /// <summary>
    /// If you want to change expiry date for each digital card, you can use this expiry type. You can set expiry date and time in fixed timezone.
    /// </summary>
    [pbr::OriginalName("EXPIRE_ON_VARIABLE_DATE_TIME")] ExpireOnVariableDateTime = 3,
    /// <summary>
    /// The digital card will set as NULL and the pass will not expire..
    /// </summary>
    [pbr::OriginalName("EXPIRE_SET_TO_NULL")] ExpireSetToNull = 4,
  }

  #endregion

  #region Messages
  /// <summary>
  /// The digital card will be expired on the expiry date. The barcode will not be rendered on digital card and the card itself will not be updated after it has been expired.
  /// </summary>
  public sealed partial class ExpirySettings : pb::IMessage<ExpirySettings> {
    private static readonly pb::MessageParser<ExpirySettings> _parser = new pb::MessageParser<ExpirySettings>(() => new ExpirySettings());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ExpirySettings> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::PKIo.ExpiryReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExpirySettings() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExpirySettings(ExpirySettings other) : this() {
      expiryType_ = other.expiryType_;
      switch (other.ExpiryOneofCase) {
        case ExpiryOneofOneofCase.FixedExpiryDate:
          FixedExpiryDate = other.FixedExpiryDate.Clone();
          break;
        case ExpiryOneofOneofCase.ExpireAfterXDays:
          ExpireAfterXDays = other.ExpireAfterXDays;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExpirySettings Clone() {
      return new ExpirySettings(this);
    }

    /// <summary>Field number for the "expiryType" field.</summary>
    public const int ExpiryTypeFieldNumber = 1;
    private global::PKIo.ExpiryType expiryType_ = global::PKIo.ExpiryType.ExpireNone;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::PKIo.ExpiryType ExpiryType {
      get { return expiryType_; }
      set {
        expiryType_ = value;
      }
    }

    /// <summary>Field number for the "fixedExpiryDate" field.</summary>
    public const int FixedExpiryDateFieldNumber = 2;
    /// <summary>
    /// The expiry date for digital membership card.
    /// Please set expiryType as EXPIRE_ON_FIXED_DATE.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::PKIo.Date FixedExpiryDate {
      get { return expiryOneofCase_ == ExpiryOneofOneofCase.FixedExpiryDate ? (global::PKIo.Date) expiryOneof_ : null; }
      set {
        expiryOneof_ = value;
        expiryOneofCase_ = value == null ? ExpiryOneofOneofCase.None : ExpiryOneofOneofCase.FixedExpiryDate;
      }
    }

    /// <summary>Field number for the "expireAfterXDays" field.</summary>
    public const int ExpireAfterXDaysFieldNumber = 3;
    /// <summary>
    /// Number of days the digital membership card is expired after the enrolment date.
    /// Please set expiryType as EXPIRE_AFTER_X_DAYS.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ExpireAfterXDays {
      get { return expiryOneofCase_ == ExpiryOneofOneofCase.ExpireAfterXDays ? (uint) expiryOneof_ : 0; }
      set {
        expiryOneof_ = value;
        expiryOneofCase_ = ExpiryOneofOneofCase.ExpireAfterXDays;
      }
    }

    private object expiryOneof_;
    /// <summary>Enum of possible cases for the "expiryOneof" oneof.</summary>
    public enum ExpiryOneofOneofCase {
      None = 0,
      FixedExpiryDate = 2,
      ExpireAfterXDays = 3,
    }
    private ExpiryOneofOneofCase expiryOneofCase_ = ExpiryOneofOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExpiryOneofOneofCase ExpiryOneofCase {
      get { return expiryOneofCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearExpiryOneof() {
      expiryOneofCase_ = ExpiryOneofOneofCase.None;
      expiryOneof_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ExpirySettings);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ExpirySettings other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ExpiryType != other.ExpiryType) return false;
      if (!object.Equals(FixedExpiryDate, other.FixedExpiryDate)) return false;
      if (ExpireAfterXDays != other.ExpireAfterXDays) return false;
      if (ExpiryOneofCase != other.ExpiryOneofCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (ExpiryType != global::PKIo.ExpiryType.ExpireNone) hash ^= ExpiryType.GetHashCode();
      if (expiryOneofCase_ == ExpiryOneofOneofCase.FixedExpiryDate) hash ^= FixedExpiryDate.GetHashCode();
      if (expiryOneofCase_ == ExpiryOneofOneofCase.ExpireAfterXDays) hash ^= ExpireAfterXDays.GetHashCode();
      hash ^= (int) expiryOneofCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (ExpiryType != global::PKIo.ExpiryType.ExpireNone) {
        output.WriteRawTag(8);
        output.WriteEnum((int) ExpiryType);
      }
      if (expiryOneofCase_ == ExpiryOneofOneofCase.FixedExpiryDate) {
        output.WriteRawTag(18);
        output.WriteMessage(FixedExpiryDate);
      }
      if (expiryOneofCase_ == ExpiryOneofOneofCase.ExpireAfterXDays) {
        output.WriteRawTag(24);
        output.WriteUInt32(ExpireAfterXDays);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (ExpiryType != global::PKIo.ExpiryType.ExpireNone) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ExpiryType);
      }
      if (expiryOneofCase_ == ExpiryOneofOneofCase.FixedExpiryDate) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FixedExpiryDate);
      }
      if (expiryOneofCase_ == ExpiryOneofOneofCase.ExpireAfterXDays) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ExpireAfterXDays);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ExpirySettings other) {
      if (other == null) {
        return;
      }
      if (other.ExpiryType != global::PKIo.ExpiryType.ExpireNone) {
        ExpiryType = other.ExpiryType;
      }
      switch (other.ExpiryOneofCase) {
        case ExpiryOneofOneofCase.FixedExpiryDate:
          if (FixedExpiryDate == null) {
            FixedExpiryDate = new global::PKIo.Date();
          }
          FixedExpiryDate.MergeFrom(other.FixedExpiryDate);
          break;
        case ExpiryOneofOneofCase.ExpireAfterXDays:
          ExpireAfterXDays = other.ExpireAfterXDays;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            ExpiryType = (global::PKIo.ExpiryType) input.ReadEnum();
            break;
          }
          case 18: {
            global::PKIo.Date subBuilder = new global::PKIo.Date();
            if (expiryOneofCase_ == ExpiryOneofOneofCase.FixedExpiryDate) {
              subBuilder.MergeFrom(FixedExpiryDate);
            }
            input.ReadMessage(subBuilder);
            FixedExpiryDate = subBuilder;
            break;
          }
          case 24: {
            ExpireAfterXDays = input.ReadUInt32();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
