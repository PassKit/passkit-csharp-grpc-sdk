// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: io/flights/barcode.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace PKFlights {

  /// <summary>Holder for reflection information generated from io/flights/barcode.proto</summary>
  public static partial class BarcodeReflection {

    #region Descriptor
    /// <summary>File descriptor for io/flights/barcode.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static BarcodeReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Chhpby9mbGlnaHRzL2JhcmNvZGUucHJvdG8SB2ZsaWdodHMaHmlvL2NvbW1v",
            "bi9jb21tb25fb2JqZWN0cy5wcm90bxoscHJvdG9jLWdlbi1zd2FnZ2VyL29w",
            "dGlvbnMvYW5ub3RhdGlvbnMucHJvdG8iwggKEENvbmRpdGlvbmFsSXRlbXMS",
            "OwoUcGFzc2VuZ2VyRGVzY3JpcHRpb24YASABKA4yHS5mbGlnaHRzLlBhc3Nl",
            "bmdlckRlc2NyaXB0aW9uEiYKDWNoZWNrSW5Tb3VyY2UYAiABKA4yDy5mbGln",
            "aHRzLlNvdXJjZRIzChpib2FyZGluZ1Bhc3NJc3N1YW5jZVNvdXJjZRgDIAEo",
            "DjIPLmZsaWdodHMuU291cmNlEicKFWJvYXJkaW5nUGFzc0lzc3VlRGF0ZRgE",
            "IAEoCzIILmlvLkRhdGUSJgoMZG9jdW1lbnRUeXBlGAUgASgOMhAuZmxpZ2h0",
            "cy5Eb2NUeXBlEhoKEmJvYXJkaW5nUGFzc0lzc3VlchgGIAEoCRLMBAoQYmFn",
            "Z2FnZVRhZ051bWJlchgHIAMoCUKxBJJBrQQyqgRUaGlzIGZpZWxkIGFsbG93",
            "cyBjYXJyaWVycyB0byBwb3B1bGF0ZSBiYWdnYWdlIHRhZyBudW1iZXJzIGFu",
            "ZCB0aGUgbnVtYmVyIG9mIGNvbnNlY3V0aXZlIGJhZ3MuIEl0IGNvbnRhaW5z",
            "IDEzIGNoYXJhY3RlcnMgY29ycmVzcG9uZGluZyB0byB0aGUgMTAgZGlnaXQg",
            "YmFnIHRhZyBudW1iZXIsIGFzIHBlciBJQVRBIEJDTSBzcGVjaWZpY2F0aW9u",
            "cywgUmVzb2x1dGlvbiA3NDAgYW5kIDMgZGlnaXRzIGlkZW50aWZ5aW5nIHRo",
            "ZSBudW1iZXIgb2YgY29uc2VjdXRpdmUgdGFncy4KMTogbGVhZGluZyBkaWdp",
            "dCDigJMgMCBmb3IgaW50ZXJsaW5lIHRhZywgMSBmb3IgZmFsbC1iYWNrIHRh",
            "ZywgMiBmb3IgaW50ZXJsaW5lIHJ1c2ggdGFnLgoyLTQ6IGNhcnJpZXIgbnVt",
            "ZXJpYyBjb2RlLgo1LTEwOiBjYXJyaWVyIGluaXRpYWwgdGFnIG51bWJlciAo",
            "bGVhZGluZyB6ZXJvcykuCjExLTEzOiBudW1iZXIgb2YgY29uc2VjdXRpdmUg",
            "dGFncyAoYWxsb3dzIGZvciB1cCB0byA5OTkgdGFncykuClVwIHRvIDIgYWRk",
            "aXRpb25hbCwgbm9uLWNvbnNlY3V0aXZlIHRhZ3MgY2FuIGJlIGFkZGVkLhI1",
            "ChFzZWxlY3RlZUluZGljYXRvchgIIAEoDjIaLmZsaWdodHMuU2VsZWN0ZWVJ",
            "bmRpY2F0b3ISSwocaW50ZXJuYXRpb25hbERvY1ZlcmlmaWNhdGlvbhgJIAEo",
            "DjIlLmZsaWdodHMuSW50ZXJuYXRpb25hbERvY1ZlcmlmaWNhdGlvbhItCg1p",
            "ZGFkSW5kaWNhdG9yGAogASgOMhYuZmxpZ2h0cy5JREFESW5kaWNhdG9yEiUK",
            "CWZhc3RUcmFjaxgLIAEoDjISLmZsaWdodHMuRmFzdFRyYWNrKu8CCg9QYXNz",
            "ZW5nZXJTdGF0dXMSGQoVSVNTVUVEX05PVF9DSEVDS0VEX0lOEAASFQoRSVNT",
            "VUVEX0NIRUNLRURfSU4QARIsCihCQUdHQUdFX0NIRUNLRURfUEFTU0VOR0VS",
            "X05PVF9DSEVDS0VEX0lOEAISKAokQkFHR0FHRV9DSEVDS0VEX1BBU1NFTkdF",
            "Ul9DSEVDS0VEX0lOEAMSIwofUEFTU0VOR0VSX1BBU1NFRF9TRUNVUklUWV9D",
            "SEVDSxAEEhkKFVBBU1NFTkdFUl9QQVNTRURfR0FURRAFEgsKB1RSQU5TSVQQ",
            "BhILCgdTVEFOREJZEAcSIwofQk9BUkRJTkdfREFUQV9SRVZBTElEQVRJT05f",
            "RE9ORRAIEjIKLk9SSUdJTkFMX0JPQVJESU5HX0xJTkVfVVNFRF9BVF9USUNL",
            "RVRfSVNTVUFOQ0UQCRIfChtVUF9PUl9ET1dOX0dSQURJTkdfUkVRVUlSRUQQ",
            "CiqQAQoUUGFzc2VuZ2VyRGVzY3JpcHRpb24SCQoFQURVTFQQABIICgRNQUxF",
            "EAESCgoGRkVNQUxFEAISCQoFQ0hJTEQQAxIKCgZJTkZBTlQQBBIQCgxOT19Q",
            "QVNTRU5HRVIQBRIVChFBRFVMVF9XSVRIX0lORkFOVBAGEhcKE1VOQUNDT01Q",
            "QU5JRURfTUlOT1IQBypACgZTb3VyY2USBQoBVxAAEgUKAUsQARIFCgFYEAIS",
            "BQoBUhADEgUKAU0QBBIFCgFPEAUSBQoBVBAGEgUKAVYQByoXCgdEb2NUeXBl",
            "EgUKAUIQABIFCgFJEAEqTQocSW50ZXJuYXRpb25hbERvY1ZlcmlmaWNhdGlv",
            "bhIQCgxOT1RfUkVRVUlSRUQQABIMCghSRVFVSVJFRBABEg0KCUNPTVBMRVRF",
            "RBACKqsBCg1JREFESW5kaWNhdG9yEggKBE5PTkUQABIICgRJRE4xEAESCAoE",
            "SUROMhACEggKBElEQjEQAxIICgRJREIyEAQSBgoCQUQQBRIGCgJERxAGEgYK",
            "AkRNEAcSBgoCR0UQCBIGCgJJRxAJEgYKAlJHEAoSBgoCVUQQCxIGCgJJRBAM",
            "EgkKBUlERlMxEA0SCQoFSURGUzIQDhIICgRJRFIxEA8SCAoESURSMhAQKkUK",
            "EVNlbGVjdGVlSW5kaWNhdG9yEhAKDE5PVF9TRUxFQ1RFRRAAEgwKCFNFTEVD",
            "VEVFEAESEAoMVFNBX1BSRUNIRUNLEAMqGQoJRmFzdFRyYWNrEgUKAU4QABIF",
            "CgFZEAFCUwoXaW8ucGFzc2tpdC5QS2lvLkZsaWdodHNaLHN0YXNoLnBhc3Nr",
            "aXQuY29tL2lvL21vZGVsL3Nkay9nby9pby9mbGlnaHRzqgIJUEtGbGlnaHRz",
            "YgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::PKIo.CommonObjectsReflection.Descriptor, global::Grpc.Gateway.ProtocGenSwagger.Options.AnnotationsReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::PKFlights.PassengerStatus), typeof(global::PKFlights.PassengerDescription), typeof(global::PKFlights.Source), typeof(global::PKFlights.DocType), typeof(global::PKFlights.InternationalDocVerification), typeof(global::PKFlights.IDADIndicator), typeof(global::PKFlights.SelecteeIndicator), typeof(global::PKFlights.FastTrack), }, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::PKFlights.ConditionalItems), global::PKFlights.ConditionalItems.Parser, new[]{ "PassengerDescription", "CheckInSource", "BoardingPassIssuanceSource", "BoardingPassIssueDate", "DocumentType", "BoardingPassIssuer", "BaggageTagNumber", "SelecteeIndicator", "InternationalDocVerification", "IdadIndicator", "FastTrack" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// Passenger Status as detailed in IATA PSC Resolution 792 Attachment 'C'. Note: all values other than 0 indicate that the passenger has checked in.
  /// </summary>
  public enum PassengerStatus {
    /// <summary>
    /// Ticket issuance/passenger not checked in
    /// </summary>
    [pbr::OriginalName("ISSUED_NOT_CHECKED_IN")] IssuedNotCheckedIn = 0,
    /// <summary>
    /// Ticket issuance/passenger checked in
    /// </summary>
    [pbr::OriginalName("ISSUED_CHECKED_IN")] IssuedCheckedIn = 1,
    /// <summary>
    /// Baggage checked - passenger not checked in
    /// </summary>
    [pbr::OriginalName("BAGGAGE_CHECKED_PASSENGER_NOT_CHECKED_IN")] BaggageCheckedPassengerNotCheckedIn = 2,
    /// <summary>
    /// Baggage checked - passenger checked in
    /// </summary>
    [pbr::OriginalName("BAGGAGE_CHECKED_PASSENGER_CHECKED_IN")] BaggageCheckedPassengerCheckedIn = 3,
    /// <summary>
    /// Passenger passed security check
    /// </summary>
    [pbr::OriginalName("PASSENGER_PASSED_SECURITY_CHECK")] PassengerPassedSecurityCheck = 4,
    /// <summary>
    /// Passenger passed gate and exit (coupon used)
    /// </summary>
    [pbr::OriginalName("PASSENGER_PASSED_GATE")] PassengerPassedGate = 5,
    /// <summary>
    /// Transit
    /// </summary>
    [pbr::OriginalName("TRANSIT")] Transit = 6,
    /// <summary>
    /// Standby. Seat number not printed on boarding pass at time of check in
    /// </summary>
    [pbr::OriginalName("STANDBY")] Standby = 7,
    /// <summary>
    /// Boarding data re-validation done
    /// </summary>
    [pbr::OriginalName("BOARDING_DATA_REVALIDATION_DONE")] BoardingDataRevalidationDone = 8,
    /// <summary>
    /// Original boarding line used at time of ticket issuance
    /// </summary>
    [pbr::OriginalName("ORIGINAL_BOARDING_LINE_USED_AT_TICKET_ISSUANCE")] OriginalBoardingLineUsedAtTicketIssuance = 9,
    /// <summary>
    /// Up or down grading required
    /// </summary>
    [pbr::OriginalName("UP_OR_DOWN_GRADING_REQUIRED")] UpOrDownGradingRequired = 10,
  }

  /// <summary>
  /// Passenger Description as detailed in IATA PSC Resolution 792 Attachment 'C'.
  /// </summary>
  public enum PassengerDescription {
    /// <summary>
    /// Adult
    /// </summary>
    [pbr::OriginalName("ADULT")] Adult = 0,
    /// <summary>
    /// Adult male
    /// </summary>
    [pbr::OriginalName("MALE")] Male = 1,
    /// <summary>
    /// Adult female
    /// </summary>
    [pbr::OriginalName("FEMALE")] Female = 2,
    /// <summary>
    /// Child
    /// </summary>
    [pbr::OriginalName("CHILD")] Child = 3,
    /// <summary>
    /// Infant
    /// </summary>
    [pbr::OriginalName("INFANT")] Infant = 4,
    /// <summary>
    /// No passenger (cabin baggage)
    /// </summary>
    [pbr::OriginalName("NO_PASSENGER")] NoPassenger = 5,
    /// <summary>
    /// Adult travelling with infant
    /// </summary>
    [pbr::OriginalName("ADULT_WITH_INFANT")] AdultWithInfant = 6,
    /// <summary>
    /// Unaccompanied minor
    /// </summary>
    [pbr::OriginalName("UNACCOMPANIED_MINOR")] UnaccompaniedMinor = 7,
  }

  /// <summary>
  /// Source of transaction.
  /// </summary>
  public enum Source {
    /// <summary>
    /// Web
    /// </summary>
    [pbr::OriginalName("W")] W = 0,
    /// <summary>
    /// Airport Kiosk
    /// </summary>
    [pbr::OriginalName("K")] K = 1,
    /// <summary>
    /// Transfer kiosk
    /// </summary>
    [pbr::OriginalName("X")] X = 2,
    /// <summary>
    /// Remote / off-site kiosk
    /// </summary>
    [pbr::OriginalName("R")] R = 3,
    /// <summary>
    /// Mobile device
    /// </summary>
    [pbr::OriginalName("M")] M = 4,
    /// <summary>
    /// Airport agent
    /// </summary>
    [pbr::OriginalName("O")] O = 5,
    /// <summary>
    /// Town agent
    /// </summary>
    [pbr::OriginalName("T")] T = 6,
    /// <summary>
    /// Third party vendor
    /// </summary>
    [pbr::OriginalName("V")] V = 7,
  }

  /// <summary>
  /// Document type that the barcode represents.
  /// </summary>
  public enum DocType {
    /// <summary>
    /// Boarding pass
    /// </summary>
    [pbr::OriginalName("B")] B = 0,
    /// <summary>
    /// Itinerary receipt
    /// </summary>
    [pbr::OriginalName("I")] I = 1,
  }

  /// <summary>
  /// International Documentation Verification.
  /// </summary>
  public enum InternationalDocVerification {
    /// <summary>
    /// No travel document verification required
    /// </summary>
    [pbr::OriginalName("NOT_REQUIRED")] NotRequired = 0,
    /// <summary>
    /// Travel document verification required before boarding
    /// </summary>
    [pbr::OriginalName("REQUIRED")] Required = 1,
    /// <summary>
    /// Travel document verification successfully completed
    /// </summary>
    [pbr::OriginalName("COMPLETED")] Completed = 2,
  }

  /// <summary>
  /// Industry Discount / Airline Discount codes. See IATA Recommended Practice 1788.
  /// </summary>
  public enum IDADIndicator {
    /// <summary>
    /// No Industry discount
    /// </summary>
    [pbr::OriginalName("NONE")] None = 0,
    /// <summary>
    /// Industry discount, other carrier employee/all other eligible persons, firm reservation
    /// </summary>
    [pbr::OriginalName("IDN1")] Idn1 = 1,
    /// <summary>
    /// Industry discount, other carrier employee/all other eligible persons, space available
    /// </summary>
    [pbr::OriginalName("IDN2")] Idn2 = 2,
    /// <summary>
    /// Industry discount, other carrier employee travelling on duty, firm reservation
    /// </summary>
    [pbr::OriginalName("IDB1")] Idb1 = 3,
    /// <summary>
    /// Industry discount, other carrier employee travelling on duty, pace available
    /// </summary>
    [pbr::OriginalName("IDB2")] Idb2 = 4,
    /// <summary>
    /// Ticket issued pursuant to Resolution 880
    /// </summary>
    [pbr::OriginalName("AD")] Ad = 5,
    /// <summary>
    /// Ticket issued pursuant to Resolution 200g
    /// </summary>
    [pbr::OriginalName("DG")] Dg = 6,
    /// <summary>
    /// Discount not covered by industry regulations (for online use only)
    /// </summary>
    [pbr::OriginalName("DM")] Dm = 7,
    /// <summary>
    /// Ticket issued pursuant to Resolution 886
    /// </summary>
    [pbr::OriginalName("GE")] Ge = 8,
    /// <summary>
    /// Ticket issued pursuant to Resolution 788
    /// </summary>
    [pbr::OriginalName("IG")] Ig = 9,
    /// <summary>
    /// Ticket issued pursuant to Resolution 888
    /// </summary>
    [pbr::OriginalName("RG")] Rg = 10,
    /// <summary>
    /// Ticket issued pursuant to Resolution 884
    /// </summary>
    [pbr::OriginalName("UD")] Ud = 11,
    /// <summary>
    /// Industry discount ticket - no classification designator
    /// </summary>
    [pbr::OriginalName("ID")] Id = 12,
    /// <summary>
    /// Industry discount, member's own employee travelling on duty, firm reservation
    /// </summary>
    [pbr::OriginalName("IDFS1")] Idfs1 = 13,
    /// <summary>
    /// Industry discount, member's own employee travelling on duty, space available
    /// </summary>
    [pbr::OriginalName("IDFS2")] Idfs2 = 14,
    /// <summary>
    /// Industry discount, member's own employee/dependant, firm reservation
    /// </summary>
    [pbr::OriginalName("IDR1")] Idr1 = 15,
    /// <summary>
    /// Industry discount, member's own employee/dependant, space available
    /// </summary>
    [pbr::OriginalName("IDR2")] Idr2 = 16,
  }

  /// <summary>
  /// Passenger security status. Note: in practical terms, this is always likely to be NOT_SELECTEE or TSA_PRECHECK since current DHS Pre-Departure Regulations only allow on-site printing of boarding passes. It is mandatory when US travel is involved.
  /// </summary>
  public enum SelecteeIndicator {
    /// <summary>
    /// Not selected for special security screening
    /// </summary>
    [pbr::OriginalName("NOT_SELECTEE")] NotSelectee = 0,
    /// <summary>
    /// Selected for special security screening
    /// </summary>
    [pbr::OriginalName("SELECTEE")] Selectee = 1,
    /// <summary>
    /// Passenger eligible for TSA PreCheck®
    /// </summary>
    [pbr::OriginalName("TSA_PRECHECK")] TsaPrecheck = 3,
  }

  /// <summary>
  /// Passenger eligibility for Fast-track privileges.
  /// </summary>
  public enum FastTrack {
    /// <summary>
    /// Not Eligible
    /// </summary>
    [pbr::OriginalName("N")] N = 0,
    /// <summary>
    /// Eligible
    /// </summary>
    [pbr::OriginalName("Y")] Y = 1,
  }

  #endregion

  #region Messages
  /// <summary>
  /// Conditional items for the flight segment as described in IATA PSC Resolution 792.  Note: items supplied or derived through other objects (E.g. Frequent Flyer information) are not supplied here.
  /// </summary>
  public sealed partial class ConditionalItems : pb::IMessage<ConditionalItems> {
    private static readonly pb::MessageParser<ConditionalItems> _parser = new pb::MessageParser<ConditionalItems>(() => new ConditionalItems());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ConditionalItems> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::PKFlights.BarcodeReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ConditionalItems() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ConditionalItems(ConditionalItems other) : this() {
      passengerDescription_ = other.passengerDescription_;
      checkInSource_ = other.checkInSource_;
      boardingPassIssuanceSource_ = other.boardingPassIssuanceSource_;
      boardingPassIssueDate_ = other.boardingPassIssueDate_ != null ? other.boardingPassIssueDate_.Clone() : null;
      documentType_ = other.documentType_;
      boardingPassIssuer_ = other.boardingPassIssuer_;
      baggageTagNumber_ = other.baggageTagNumber_.Clone();
      selecteeIndicator_ = other.selecteeIndicator_;
      internationalDocVerification_ = other.internationalDocVerification_;
      idadIndicator_ = other.idadIndicator_;
      fastTrack_ = other.fastTrack_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ConditionalItems Clone() {
      return new ConditionalItems(this);
    }

    /// <summary>Field number for the "passengerDescription" field.</summary>
    public const int PassengerDescriptionFieldNumber = 1;
    private global::PKFlights.PassengerDescription passengerDescription_ = global::PKFlights.PassengerDescription.Adult;
    /// <summary>
    /// Passenger Status as detailed in IATA PSC Resolution 792 Attachment 'C'. Note: all values other than 0 indicate that the passenger has checked in.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::PKFlights.PassengerDescription PassengerDescription {
      get { return passengerDescription_; }
      set {
        passengerDescription_ = value;
      }
    }

    /// <summary>Field number for the "checkInSource" field.</summary>
    public const int CheckInSourceFieldNumber = 2;
    private global::PKFlights.Source checkInSource_ = global::PKFlights.Source.W;
    /// <summary>
    /// Source of checkin as detailed in IATA PSC Resolution 792 Attachment 'C'.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::PKFlights.Source CheckInSource {
      get { return checkInSource_; }
      set {
        checkInSource_ = value;
      }
    }

    /// <summary>Field number for the "boardingPassIssuanceSource" field.</summary>
    public const int BoardingPassIssuanceSourceFieldNumber = 3;
    private global::PKFlights.Source boardingPassIssuanceSource_ = global::PKFlights.Source.W;
    /// <summary>
    /// Source of boarding pass issuance as detailed in IATA PSC Resolution 792 Attachment 'C'.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::PKFlights.Source BoardingPassIssuanceSource {
      get { return boardingPassIssuanceSource_; }
      set {
        boardingPassIssuanceSource_ = value;
      }
    }

    /// <summary>Field number for the "boardingPassIssueDate" field.</summary>
    public const int BoardingPassIssueDateFieldNumber = 4;
    private global::PKIo.Date boardingPassIssueDate_;
    /// <summary>
    /// Date of boarding pass issuance, local to the boarding point.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::PKIo.Date BoardingPassIssueDate {
      get { return boardingPassIssueDate_; }
      set {
        boardingPassIssueDate_ = value;
      }
    }

    /// <summary>Field number for the "documentType" field.</summary>
    public const int DocumentTypeFieldNumber = 5;
    private global::PKFlights.DocType documentType_ = global::PKFlights.DocType.B;
    /// <summary>
    /// Document type that the barcode represents.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::PKFlights.DocType DocumentType {
      get { return documentType_; }
      set {
        documentType_ = value;
      }
    }

    /// <summary>Field number for the "boardingPassIssuer" field.</summary>
    public const int BoardingPassIssuerFieldNumber = 6;
    private string boardingPassIssuer_ = "";
    /// <summary>
    /// IATA or ICAO designator of boarding pass issuer.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string BoardingPassIssuer {
      get { return boardingPassIssuer_; }
      set {
        boardingPassIssuer_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "baggageTagNumber" field.</summary>
    public const int BaggageTagNumberFieldNumber = 7;
    private static readonly pb::FieldCodec<string> _repeated_baggageTagNumber_codec
        = pb::FieldCodec.ForString(58);
    private readonly pbc::RepeatedField<string> baggageTagNumber_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// This field allows carriers to populate baggage tag numbers and the number of consecutive bags. It contains 13 characters corresponding to the 10 digit bag tag number, as per IATA BCM specifications, Resolution 740 and 3 digits identifying the number of consecutive tags.\n1: leading digit – 0 for interline tag, 1 for fall-back tag, 2 for interline rush tag.\n2-4: carrier numeric code.\n5-10: carrier initial tag number (leading zeros).\n11-13: number of consecutive tags (allows for up to 999 tags).\nUp to 2 additional, non-consecutive tags can be added.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> BaggageTagNumber {
      get { return baggageTagNumber_; }
    }

    /// <summary>Field number for the "selecteeIndicator" field.</summary>
    public const int SelecteeIndicatorFieldNumber = 8;
    private global::PKFlights.SelecteeIndicator selecteeIndicator_ = global::PKFlights.SelecteeIndicator.NotSelectee;
    /// <summary>
    /// Passenger security status. Note: in practical terms, this is always likely to be NOT_SELECTEE or TSA_PRECHECK since current DHS Pre-Departure Regulations only allow on-site printing of boarding passes. It is mandatory when US travel is involved.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::PKFlights.SelecteeIndicator SelecteeIndicator {
      get { return selecteeIndicator_; }
      set {
        selecteeIndicator_ = value;
      }
    }

    /// <summary>Field number for the "internationalDocVerification" field.</summary>
    public const int InternationalDocVerificationFieldNumber = 9;
    private global::PKFlights.InternationalDocVerification internationalDocVerification_ = global::PKFlights.InternationalDocVerification.NotRequired;
    /// <summary>
    /// International Documentation Verification status as detailed in IATA PSC Resolution 792 Attachment 'C'.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::PKFlights.InternationalDocVerification InternationalDocVerification {
      get { return internationalDocVerification_; }
      set {
        internationalDocVerification_ = value;
      }
    }

    /// <summary>Field number for the "idadIndicator" field.</summary>
    public const int IdadIndicatorFieldNumber = 10;
    private global::PKFlights.IDADIndicator idadIndicator_ = global::PKFlights.IDADIndicator.None;
    /// <summary>
    /// Industry Discount / Airline Discount codes. See IATA Recommended Practice 1788.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::PKFlights.IDADIndicator IdadIndicator {
      get { return idadIndicator_; }
      set {
        idadIndicator_ = value;
      }
    }

    /// <summary>Field number for the "fastTrack" field.</summary>
    public const int FastTrackFieldNumber = 11;
    private global::PKFlights.FastTrack fastTrack_ = global::PKFlights.FastTrack.N;
    /// <summary>
    /// Passenger eligibility for Fast-track privileges.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::PKFlights.FastTrack FastTrack {
      get { return fastTrack_; }
      set {
        fastTrack_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ConditionalItems);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ConditionalItems other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (PassengerDescription != other.PassengerDescription) return false;
      if (CheckInSource != other.CheckInSource) return false;
      if (BoardingPassIssuanceSource != other.BoardingPassIssuanceSource) return false;
      if (!object.Equals(BoardingPassIssueDate, other.BoardingPassIssueDate)) return false;
      if (DocumentType != other.DocumentType) return false;
      if (BoardingPassIssuer != other.BoardingPassIssuer) return false;
      if(!baggageTagNumber_.Equals(other.baggageTagNumber_)) return false;
      if (SelecteeIndicator != other.SelecteeIndicator) return false;
      if (InternationalDocVerification != other.InternationalDocVerification) return false;
      if (IdadIndicator != other.IdadIndicator) return false;
      if (FastTrack != other.FastTrack) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (PassengerDescription != global::PKFlights.PassengerDescription.Adult) hash ^= PassengerDescription.GetHashCode();
      if (CheckInSource != global::PKFlights.Source.W) hash ^= CheckInSource.GetHashCode();
      if (BoardingPassIssuanceSource != global::PKFlights.Source.W) hash ^= BoardingPassIssuanceSource.GetHashCode();
      if (boardingPassIssueDate_ != null) hash ^= BoardingPassIssueDate.GetHashCode();
      if (DocumentType != global::PKFlights.DocType.B) hash ^= DocumentType.GetHashCode();
      if (BoardingPassIssuer.Length != 0) hash ^= BoardingPassIssuer.GetHashCode();
      hash ^= baggageTagNumber_.GetHashCode();
      if (SelecteeIndicator != global::PKFlights.SelecteeIndicator.NotSelectee) hash ^= SelecteeIndicator.GetHashCode();
      if (InternationalDocVerification != global::PKFlights.InternationalDocVerification.NotRequired) hash ^= InternationalDocVerification.GetHashCode();
      if (IdadIndicator != global::PKFlights.IDADIndicator.None) hash ^= IdadIndicator.GetHashCode();
      if (FastTrack != global::PKFlights.FastTrack.N) hash ^= FastTrack.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (PassengerDescription != global::PKFlights.PassengerDescription.Adult) {
        output.WriteRawTag(8);
        output.WriteEnum((int) PassengerDescription);
      }
      if (CheckInSource != global::PKFlights.Source.W) {
        output.WriteRawTag(16);
        output.WriteEnum((int) CheckInSource);
      }
      if (BoardingPassIssuanceSource != global::PKFlights.Source.W) {
        output.WriteRawTag(24);
        output.WriteEnum((int) BoardingPassIssuanceSource);
      }
      if (boardingPassIssueDate_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(BoardingPassIssueDate);
      }
      if (DocumentType != global::PKFlights.DocType.B) {
        output.WriteRawTag(40);
        output.WriteEnum((int) DocumentType);
      }
      if (BoardingPassIssuer.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(BoardingPassIssuer);
      }
      baggageTagNumber_.WriteTo(output, _repeated_baggageTagNumber_codec);
      if (SelecteeIndicator != global::PKFlights.SelecteeIndicator.NotSelectee) {
        output.WriteRawTag(64);
        output.WriteEnum((int) SelecteeIndicator);
      }
      if (InternationalDocVerification != global::PKFlights.InternationalDocVerification.NotRequired) {
        output.WriteRawTag(72);
        output.WriteEnum((int) InternationalDocVerification);
      }
      if (IdadIndicator != global::PKFlights.IDADIndicator.None) {
        output.WriteRawTag(80);
        output.WriteEnum((int) IdadIndicator);
      }
      if (FastTrack != global::PKFlights.FastTrack.N) {
        output.WriteRawTag(88);
        output.WriteEnum((int) FastTrack);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (PassengerDescription != global::PKFlights.PassengerDescription.Adult) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) PassengerDescription);
      }
      if (CheckInSource != global::PKFlights.Source.W) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) CheckInSource);
      }
      if (BoardingPassIssuanceSource != global::PKFlights.Source.W) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) BoardingPassIssuanceSource);
      }
      if (boardingPassIssueDate_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(BoardingPassIssueDate);
      }
      if (DocumentType != global::PKFlights.DocType.B) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DocumentType);
      }
      if (BoardingPassIssuer.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(BoardingPassIssuer);
      }
      size += baggageTagNumber_.CalculateSize(_repeated_baggageTagNumber_codec);
      if (SelecteeIndicator != global::PKFlights.SelecteeIndicator.NotSelectee) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) SelecteeIndicator);
      }
      if (InternationalDocVerification != global::PKFlights.InternationalDocVerification.NotRequired) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) InternationalDocVerification);
      }
      if (IdadIndicator != global::PKFlights.IDADIndicator.None) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) IdadIndicator);
      }
      if (FastTrack != global::PKFlights.FastTrack.N) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) FastTrack);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ConditionalItems other) {
      if (other == null) {
        return;
      }
      if (other.PassengerDescription != global::PKFlights.PassengerDescription.Adult) {
        PassengerDescription = other.PassengerDescription;
      }
      if (other.CheckInSource != global::PKFlights.Source.W) {
        CheckInSource = other.CheckInSource;
      }
      if (other.BoardingPassIssuanceSource != global::PKFlights.Source.W) {
        BoardingPassIssuanceSource = other.BoardingPassIssuanceSource;
      }
      if (other.boardingPassIssueDate_ != null) {
        if (boardingPassIssueDate_ == null) {
          BoardingPassIssueDate = new global::PKIo.Date();
        }
        BoardingPassIssueDate.MergeFrom(other.BoardingPassIssueDate);
      }
      if (other.DocumentType != global::PKFlights.DocType.B) {
        DocumentType = other.DocumentType;
      }
      if (other.BoardingPassIssuer.Length != 0) {
        BoardingPassIssuer = other.BoardingPassIssuer;
      }
      baggageTagNumber_.Add(other.baggageTagNumber_);
      if (other.SelecteeIndicator != global::PKFlights.SelecteeIndicator.NotSelectee) {
        SelecteeIndicator = other.SelecteeIndicator;
      }
      if (other.InternationalDocVerification != global::PKFlights.InternationalDocVerification.NotRequired) {
        InternationalDocVerification = other.InternationalDocVerification;
      }
      if (other.IdadIndicator != global::PKFlights.IDADIndicator.None) {
        IdadIndicator = other.IdadIndicator;
      }
      if (other.FastTrack != global::PKFlights.FastTrack.N) {
        FastTrack = other.FastTrack;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            PassengerDescription = (global::PKFlights.PassengerDescription) input.ReadEnum();
            break;
          }
          case 16: {
            CheckInSource = (global::PKFlights.Source) input.ReadEnum();
            break;
          }
          case 24: {
            BoardingPassIssuanceSource = (global::PKFlights.Source) input.ReadEnum();
            break;
          }
          case 34: {
            if (boardingPassIssueDate_ == null) {
              BoardingPassIssueDate = new global::PKIo.Date();
            }
            input.ReadMessage(BoardingPassIssueDate);
            break;
          }
          case 40: {
            DocumentType = (global::PKFlights.DocType) input.ReadEnum();
            break;
          }
          case 50: {
            BoardingPassIssuer = input.ReadString();
            break;
          }
          case 58: {
            baggageTagNumber_.AddEntriesFrom(input, _repeated_baggageTagNumber_codec);
            break;
          }
          case 64: {
            SelecteeIndicator = (global::PKFlights.SelecteeIndicator) input.ReadEnum();
            break;
          }
          case 72: {
            InternationalDocVerification = (global::PKFlights.InternationalDocVerification) input.ReadEnum();
            break;
          }
          case 80: {
            IdadIndicator = (global::PKFlights.IDADIndicator) input.ReadEnum();
            break;
          }
          case 88: {
            FastTrack = (global::PKFlights.FastTrack) input.ReadEnum();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
